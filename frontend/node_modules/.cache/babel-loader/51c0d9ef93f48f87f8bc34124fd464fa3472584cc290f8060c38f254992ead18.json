{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useEffect, useState } from 'react';\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = new Set();\n    this.errorHandlers = new Set();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000; // Start with 1 second\n    this.maxReconnectDelay = 10000; // Max 10 seconds\n    this.connectionStatus = 'disconnected';\n    this.connectionStatusListeners = new Set();\n    this.reconnectTimeout = null;\n    this.url = null;\n    this.dispatch = null;\n  }\n\n  // Set the Redux dispatch function\n  setDispatch(dispatch) {\n    this.dispatch = dispatch;\n  }\n  connect(url) {\n    // Clean up any existing connection\n    if (this.socket) {\n      try {\n        this.socket.onopen = null;\n        this.socket.onmessage = null;\n        this.socket.onerror = null;\n        this.socket.onclose = null;\n        if (this.socket.readyState === WebSocket.OPEN) {\n          this.socket.close();\n        }\n      } catch (e) {\n        console.warn('[WebSocket] Error cleaning up previous connection:', e);\n      }\n    }\n    this.url = url;\n    console.log(`[WebSocket] Initializing connection to ${url}`);\n    this.updateConnectionStatus('connecting');\n    return new Promise((resolve, reject) => {\n      try {\n        // Create new WebSocket instance\n        if (this.socket) {\n          console.log('[WebSocket] Closing existing connection...');\n          this.disconnect();\n        }\n        console.log(`[WebSocket] Creating new WebSocket instance to ${url}`);\n        this.socket = new WebSocket(url);\n        this.updateConnectionStatus('connecting');\n\n        // Notify Redux store about connection attempt\n        if (this.dispatch) {\n          this.dispatch({\n            type: 'network/updateCaptureStatus',\n            payload: {\n              status: 'connecting'\n            }\n          });\n        }\n\n        // Bind event handlers\n        this.socket.onopen = event => {\n          console.log('[WebSocket] Connection established', {\n            url: this.socket.url,\n            protocol: this.socket.protocol,\n            extensions: this.socket.extensions,\n            binaryType: this.socket.binaryType\n          });\n          this.reconnectAttempts = 0;\n          this.updateConnectionStatus('connected');\n          this.notifyConnectionStatus('connected');\n\n          // Send initial handshake or subscription message if needed\n          try {\n            const initMessage = JSON.stringify({\n              type: 'init',\n              timestamp: new Date().toISOString(),\n              client: 'sentinel-ai-frontend'\n            });\n            this.socket.send(initMessage);\n            console.debug('[WebSocket] Sent init message');\n          } catch (e) {\n            console.warn('[WebSocket] Failed to send init message:', e);\n          }\n          resolve();\n        };\n        this.socket.onerror = error => {\n          const errorInfo = {\n            message: error.message || 'Unknown WebSocket error',\n            type: error.type || 'unknown',\n            readyState: this.socket ? this.socket.readyState : 'no-socket',\n            url: this.url,\n            timestamp: new Date().toISOString()\n          };\n          console.error('[WebSocket] Connection error:', errorInfo);\n          this.updateConnectionStatus('error');\n          this.notifyErrorHandlers(new Error(errorInfo.message));\n\n          // Only reject if this is the initial connection attempt\n          if (this.reconnectAttempts === 0) {\n            const wsError = new Error(`WebSocket error: ${errorInfo.message}`);\n            wsError.details = errorInfo;\n            console.error('[WebSocket] Rejecting connection promise', wsError);\n            reject(wsError);\n          }\n        };\n        this.socket.onmessage = event => {\n          try {\n            const message = event.data;\n            if (!message) {\n              console.debug('[WebSocket] Received empty message, ignoring');\n              return;\n            }\n\n            // Try to parse JSON if it's a string\n            let parsedData;\n            if (typeof message === 'string') {\n              try {\n                parsedData = JSON.parse(message);\n              } catch (parseError) {\n                console.debug('[WebSocket] Received non-JSON message:', message);\n                return; // Skip non-JSON messages\n              }\n            } else if (typeof message === 'object') {\n              parsedData = message; // Already parsed (e.g., from MessageEvent)\n            } else {\n              console.debug('[WebSocket] Received message with unsupported type:', typeof message);\n              return;\n            }\n            console.debug('[WebSocket] Processing message:', parsedData);\n            this.processMessage(parsedData);\n          } catch (error) {\n            console.error('[WebSocket] Error in onmessage handler:', {\n              error: error.message,\n              stack: error.stack,\n              rawData: event === null || event === void 0 ? void 0 : event.data\n            });\n            this.notifyErrorHandlers(error);\n          }\n        };\n        this.socket.onclose = event => {\n          console.log('[WebSocket] Connection closed', {\n            code: event.code,\n            reason: event.reason,\n            wasClean: event.wasClean\n          });\n          const newStatus = 'disconnected';\n          this.updateConnectionStatus(newStatus);\n\n          // Notify Redux store about disconnection\n          if (this.dispatch) {\n            this.dispatch({\n              type: 'network/updateCaptureStatus',\n              payload: {\n                status: newStatus\n              }\n            });\n          }\n          this.attemptReconnect();\n        };\n      } catch (error) {\n        console.error('WebSocket Connection Error:', error);\n        reject(error);\n      }\n    });\n  }\n  updateConnectionStatus(status) {\n    this.connectionStatus = status;\n    this.notifyStatusChange(status);\n  }\n  onStatusChange(callback) {\n    this.connectionStatusListeners.add(callback);\n    return () => this.connectionStatusListeners.delete(callback);\n  }\n  notifyStatusChange(status) {\n    this.connectionStatusListeners.forEach(callback => {\n      try {\n        callback(status);\n      } catch (error) {\n        console.error('Error in status change handler:', error);\n      }\n    });\n  }\n  getStatus() {\n    return this.connectionStatus;\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.messageHandlers.clear();\n  }\n  send(message) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      try {\n        const messageString = typeof message === 'string' ? message : JSON.stringify(message);\n        this.socket.send(messageString);\n        return true;\n      } catch (error) {\n        console.error('Error sending WebSocket message:', error);\n        return false;\n      }\n    }\n    console.warn('WebSocket is not connected');\n    return false;\n  }\n  addMessageHandler(handler) {\n    this.messageHandlers.add(handler);\n\n    // Return cleanup function\n    return () => this.messageHandlers.delete(handler);\n  }\n  removeMessageHandler(handler) {\n    this.messageHandlers.delete(handler);\n  }\n  processMessage(data) {\n    if (!data) {\n      console.warn('[WebSocket] processMessage called with no data');\n      return;\n    }\n    console.debug('[WebSocket] Processing message data:', data);\n    try {\n      // Notify all message handlers\n      this.messageHandlers.forEach(handler => {\n        try {\n          if (typeof handler === 'function') {\n            handler(data);\n          }\n        } catch (error) {\n          console.error('[WebSocket] Error in message handler:', error);\n        }\n      });\n\n      // Dispatch to Redux if dispatch is available\n      if (this.dispatch) {\n        // Handle different message formats\n        if (data.type) {\n          // Format: { type: 'packet', data: {...} }\n          if (data.type === 'packet' && data.data) {\n            this.dispatch({\n              type: 'network/addPacket',\n              payload: data.data\n            });\n          } else if (data.type === 'status') {\n            this.dispatch({\n              type: 'network/updateCaptureStatus',\n              payload: data.data || data\n            });\n          } else if (data.type === 'interfaces') {\n            this.dispatch({\n              type: 'network/updateInterfaces',\n              payload: data.data || data\n            });\n          } else if (data.type === 'stats') {\n            this.dispatch({\n              type: 'network/updateStats',\n              payload: data.data || data\n            });\n          } else if (data.type === 'bandwidth') {\n            this.dispatch({\n              type: 'network/updateBandwidth',\n              payload: data.data || data\n            });\n          }\n        } else if (data.protocol) {\n          // Format: Direct packet object\n          this.dispatch({\n            type: 'network/addPacket',\n            payload: data\n          });\n        } else if (data.isCapturing !== undefined) {\n          // Format: Direct status object\n          this.dispatch({\n            type: 'network/updateCaptureStatus',\n            payload: data\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error processing WebSocket message:', {\n        error: error.message,\n        stack: error.stack,\n        message: message,\n        parsedData: data\n      });\n    }\n  }\n  onError(handler) {\n    if (typeof handler === 'function') {\n      this.errorHandlers.add(handler);\n      return () => this.errorHandlers.delete(handler);\n    }\n    return () => {};\n  }\n  removeErrorHandler(handler) {\n    this.errorHandlers.delete(handler);\n  }\n  notifyErrorHandlers(error) {\n    this.errorHandlers.forEach(handler => {\n      try {\n        handler(error);\n      } catch (err) {\n        console.error('Error in error handler:', err);\n      }\n    });\n  }\n  attemptReconnect() {\n    this.reconnectAttempts++;\n    this.reconnectDelay = Math.min(this.reconnectDelay * 2, this.maxReconnectDelay);\n    this.reconnectTimeout = setTimeout(() => {\n      this.connect(this.url);\n    }, this.reconnectDelay);\n  }\n}\n\n// Export a singleton instance\nexport const webSocketService = new WebSocketService();\n\n// Helper hook for React components\nexport const useWebSocket = (onMessage, dependencies = []) => {\n  _s();\n  const [isConnected, setIsConnected] = React.useState(false);\n  const [error, setError] = React.useState(null);\n  React.useEffect(() => {\n    const handleMessage = message => {\n      if (message.type === 'connection/established') {\n        setIsConnected(true);\n        setError(null);\n      } else if (message.type === 'connection/error') {\n        setError(message.payload);\n      }\n      if (onMessage) {\n        onMessage(message);\n      }\n    };\n\n    // Add the handler\n    const removeHandler = webSocketService.addMessageHandler(handleMessage);\n\n    // Clean up\n    return () => {\n      removeHandler();\n    };\n  }, [onMessage, ...dependencies]);\n};\n_s(useWebSocket, \"pC3TVIB/x3LrkaCp5yIVZyn0G4I=\");","map":{"version":3,"names":["React","useEffect","useState","WebSocketService","constructor","socket","messageHandlers","Set","errorHandlers","reconnectAttempts","maxReconnectAttempts","reconnectDelay","maxReconnectDelay","connectionStatus","connectionStatusListeners","reconnectTimeout","url","dispatch","setDispatch","connect","onopen","onmessage","onerror","onclose","readyState","WebSocket","OPEN","close","e","console","warn","log","updateConnectionStatus","Promise","resolve","reject","disconnect","type","payload","status","event","protocol","extensions","binaryType","notifyConnectionStatus","initMessage","JSON","stringify","timestamp","Date","toISOString","client","send","debug","error","errorInfo","message","notifyErrorHandlers","Error","wsError","details","data","parsedData","parse","parseError","processMessage","stack","rawData","code","reason","wasClean","newStatus","attemptReconnect","notifyStatusChange","onStatusChange","callback","add","delete","forEach","getStatus","clear","messageString","addMessageHandler","handler","removeMessageHandler","isCapturing","undefined","onError","removeErrorHandler","err","Math","min","setTimeout","webSocketService","useWebSocket","onMessage","dependencies","_s","isConnected","setIsConnected","setError","handleMessage","removeHandler"],"sources":["C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/src/services/websocketService.js"],"sourcesContent":["import React, { useEffect, useState } from 'react';\n\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = new Set();\n    this.errorHandlers = new Set();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000; // Start with 1 second\n    this.maxReconnectDelay = 10000; // Max 10 seconds\n    this.connectionStatus = 'disconnected';\n    this.connectionStatusListeners = new Set();\n    this.reconnectTimeout = null;\n    this.url = null;\n    this.dispatch = null;\n  }\n\n  // Set the Redux dispatch function\n  setDispatch(dispatch) {\n    this.dispatch = dispatch;\n  }\n\n  connect(url) {\n    // Clean up any existing connection\n    if (this.socket) {\n      try {\n        this.socket.onopen = null;\n        this.socket.onmessage = null;\n        this.socket.onerror = null;\n        this.socket.onclose = null;\n        if (this.socket.readyState === WebSocket.OPEN) {\n          this.socket.close();\n        }\n      } catch (e) {\n        console.warn('[WebSocket] Error cleaning up previous connection:', e);\n      }\n    }\n\n    this.url = url;\n    console.log(`[WebSocket] Initializing connection to ${url}`);\n    this.updateConnectionStatus('connecting');\n\n    return new Promise((resolve, reject) => {\n      try {\n        // Create new WebSocket instance\n        if (this.socket) {\n          console.log('[WebSocket] Closing existing connection...');\n          this.disconnect();\n        }\n\n        console.log(`[WebSocket] Creating new WebSocket instance to ${url}`);\n        this.socket = new WebSocket(url);\n        this.updateConnectionStatus('connecting');\n\n        // Notify Redux store about connection attempt\n        if (this.dispatch) {\n          this.dispatch({ type: 'network/updateCaptureStatus', payload: { status: 'connecting' } });\n        }\n\n        // Bind event handlers\n        this.socket.onopen = (event) => {\n          console.log('[WebSocket] Connection established', {\n            url: this.socket.url,\n            protocol: this.socket.protocol,\n            extensions: this.socket.extensions,\n            binaryType: this.socket.binaryType\n          });\n          \n          this.reconnectAttempts = 0;\n          this.updateConnectionStatus('connected');\n          this.notifyConnectionStatus('connected');\n          \n          // Send initial handshake or subscription message if needed\n          try {\n            const initMessage = JSON.stringify({\n              type: 'init',\n              timestamp: new Date().toISOString(),\n              client: 'sentinel-ai-frontend'\n            });\n            this.socket.send(initMessage);\n            console.debug('[WebSocket] Sent init message');\n          } catch (e) {\n            console.warn('[WebSocket] Failed to send init message:', e);\n          }\n          \n          resolve();\n        };\n\n        this.socket.onerror = (error) => {\n          const errorInfo = {\n            message: error.message || 'Unknown WebSocket error',\n            type: error.type || 'unknown',\n            readyState: this.socket ? this.socket.readyState : 'no-socket',\n            url: this.url,\n            timestamp: new Date().toISOString()\n          };\n          \n          console.error('[WebSocket] Connection error:', errorInfo);\n          this.updateConnectionStatus('error');\n          this.notifyErrorHandlers(new Error(errorInfo.message));\n          \n          // Only reject if this is the initial connection attempt\n          if (this.reconnectAttempts === 0) {\n            const wsError = new Error(`WebSocket error: ${errorInfo.message}`);\n            wsError.details = errorInfo;\n            console.error('[WebSocket] Rejecting connection promise', wsError);\n            reject(wsError);\n          }\n        };\n\n        this.socket.onmessage = (event) => {\n          try {\n            const message = event.data;\n            \n            if (!message) {\n              console.debug('[WebSocket] Received empty message, ignoring');\n              return;\n            }\n            \n            // Try to parse JSON if it's a string\n            let parsedData;\n            if (typeof message === 'string') {\n              try {\n                parsedData = JSON.parse(message);\n              } catch (parseError) {\n                console.debug('[WebSocket] Received non-JSON message:', message);\n                return; // Skip non-JSON messages\n              }\n            } else if (typeof message === 'object') {\n              parsedData = message; // Already parsed (e.g., from MessageEvent)\n            } else {\n              console.debug('[WebSocket] Received message with unsupported type:', typeof message);\n              return;\n            }\n            \n            console.debug('[WebSocket] Processing message:', parsedData);\n            this.processMessage(parsedData);\n            \n          } catch (error) {\n            console.error('[WebSocket] Error in onmessage handler:', {\n              error: error.message,\n              stack: error.stack,\n              rawData: event?.data\n            });\n            this.notifyErrorHandlers(error);\n          }\n        };\n\n        this.socket.onclose = (event) => {\n          console.log('[WebSocket] Connection closed', {\n            code: event.code,\n            reason: event.reason,\n            wasClean: event.wasClean\n          });\n\n          const newStatus = 'disconnected';\n          this.updateConnectionStatus(newStatus);\n\n          // Notify Redux store about disconnection\n          if (this.dispatch) {\n            this.dispatch({ type: 'network/updateCaptureStatus', payload: { status: newStatus } });\n          }\n\n          this.attemptReconnect();\n        };\n      } catch (error) {\n        console.error('WebSocket Connection Error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  updateConnectionStatus(status) {\n    this.connectionStatus = status;\n    this.notifyStatusChange(status);\n  }\n\n  onStatusChange(callback) {\n    this.connectionStatusListeners.add(callback);\n    return () => this.connectionStatusListeners.delete(callback);\n  }\n\n  notifyStatusChange(status) {\n    this.connectionStatusListeners.forEach(callback => {\n      try {\n        callback(status);\n      } catch (error) {\n        console.error('Error in status change handler:', error);\n      }\n    });\n  }\n\n  getStatus() {\n    return this.connectionStatus;\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.messageHandlers.clear();\n  }\n\n  send(message) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      try {\n        const messageString = typeof message === 'string' ? message : JSON.stringify(message);\n        this.socket.send(messageString);\n        return true;\n      } catch (error) {\n        console.error('Error sending WebSocket message:', error);\n        return false;\n      }\n    }\n    console.warn('WebSocket is not connected');\n    return false;\n  }\n\n  addMessageHandler(handler) {\n    this.messageHandlers.add(handler);\n\n    // Return cleanup function\n    return () => this.messageHandlers.delete(handler);\n  }\n\n  removeMessageHandler(handler) {\n    this.messageHandlers.delete(handler);\n  }\n\n  processMessage(data) {\n    if (!data) {\n      console.warn('[WebSocket] processMessage called with no data');\n      return;\n    }\n\n    console.debug('[WebSocket] Processing message data:', data);\n\n    try {\n      // Notify all message handlers\n      this.messageHandlers.forEach(handler => {\n        try {\n          if (typeof handler === 'function') {\n            handler(data);\n          }\n        } catch (error) {\n          console.error('[WebSocket] Error in message handler:', error);\n        }\n      });\n\n      // Dispatch to Redux if dispatch is available\n      if (this.dispatch) {\n        // Handle different message formats\n        if (data.type) {\n          // Format: { type: 'packet', data: {...} }\n          if (data.type === 'packet' && data.data) {\n            this.dispatch({ \n              type: 'network/addPacket', \n              payload: data.data \n            });\n          } else if (data.type === 'status') {\n            this.dispatch({ \n              type: 'network/updateCaptureStatus', \n              payload: data.data || data \n            });\n          } else if (data.type === 'interfaces') {\n            this.dispatch({ \n              type: 'network/updateInterfaces', \n              payload: data.data || data \n            });\n          } else if (data.type === 'stats') {\n            this.dispatch({ \n              type: 'network/updateStats', \n              payload: data.data || data \n            });\n          } else if (data.type === 'bandwidth') {\n            this.dispatch({ \n              type: 'network/updateBandwidth', \n              payload: data.data || data \n            });\n          }\n        } else if (data.protocol) {\n          // Format: Direct packet object\n          this.dispatch({ \n            type: 'network/addPacket', \n            payload: data \n          });\n        } else if (data.isCapturing !== undefined) {\n          // Format: Direct status object\n          this.dispatch({ \n            type: 'network/updateCaptureStatus', \n            payload: data \n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error processing WebSocket message:', {\n        error: error.message,\n        stack: error.stack,\n        message: message,\n        parsedData: data\n      });\n    }\n  }\n\n  onError(handler) {\n    if (typeof handler === 'function') {\n      this.errorHandlers.add(handler);\n      return () => this.errorHandlers.delete(handler);\n    }\n    return () => { };\n  }\n\n  removeErrorHandler(handler) {\n    this.errorHandlers.delete(handler);\n  }\n\n  notifyErrorHandlers(error) {\n    this.errorHandlers.forEach(handler => {\n      try {\n        handler(error);\n      } catch (err) {\n        console.error('Error in error handler:', err);\n      }\n    });\n  }\n\n  attemptReconnect() {\n    this.reconnectAttempts++;\n    this.reconnectDelay = Math.min(this.reconnectDelay * 2, this.maxReconnectDelay);\n    this.reconnectTimeout = setTimeout(() => {\n      this.connect(this.url);\n    }, this.reconnectDelay);\n  }\n}\n\n// Export a singleton instance\nexport const webSocketService = new WebSocketService();\n\n// Helper hook for React components\nexport const useWebSocket = (onMessage, dependencies = []) => {\n  const [isConnected, setIsConnected] = React.useState(false);\n  const [error, setError] = React.useState(null);\n\n  React.useEffect(() => {\n    const handleMessage = (message) => {\n      if (message.type === 'connection/established') {\n        setIsConnected(true);\n        setError(null);\n      } else if (message.type === 'connection/error') {\n        setError(message.payload);\n      }\n\n      if (onMessage) {\n        onMessage(message);\n      }\n    };\n\n    // Add the handler\n    const removeHandler = webSocketService.addMessageHandler(handleMessage);\n\n    // Clean up\n    return () => {\n      removeHandler();\n    };\n  }, [onMessage, ...dependencies]);\n};\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAElD,MAAMC,gBAAgB,CAAC;EACrBC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;IAChC,IAAI,CAACC,aAAa,GAAG,IAAID,GAAG,CAAC,CAAC;IAC9B,IAAI,CAACE,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,oBAAoB,GAAG,CAAC;IAC7B,IAAI,CAACC,cAAc,GAAG,IAAI,CAAC,CAAC;IAC5B,IAAI,CAACC,iBAAiB,GAAG,KAAK,CAAC,CAAC;IAChC,IAAI,CAACC,gBAAgB,GAAG,cAAc;IACtC,IAAI,CAACC,yBAAyB,GAAG,IAAIP,GAAG,CAAC,CAAC;IAC1C,IAAI,CAACQ,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACC,GAAG,GAAG,IAAI;IACf,IAAI,CAACC,QAAQ,GAAG,IAAI;EACtB;;EAEA;EACAC,WAAWA,CAACD,QAAQ,EAAE;IACpB,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC1B;EAEAE,OAAOA,CAACH,GAAG,EAAE;IACX;IACA,IAAI,IAAI,CAACX,MAAM,EAAE;MACf,IAAI;QACF,IAAI,CAACA,MAAM,CAACe,MAAM,GAAG,IAAI;QACzB,IAAI,CAACf,MAAM,CAACgB,SAAS,GAAG,IAAI;QAC5B,IAAI,CAAChB,MAAM,CAACiB,OAAO,GAAG,IAAI;QAC1B,IAAI,CAACjB,MAAM,CAACkB,OAAO,GAAG,IAAI;QAC1B,IAAI,IAAI,CAAClB,MAAM,CAACmB,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;UAC7C,IAAI,CAACrB,MAAM,CAACsB,KAAK,CAAC,CAAC;QACrB;MACF,CAAC,CAAC,OAAOC,CAAC,EAAE;QACVC,OAAO,CAACC,IAAI,CAAC,oDAAoD,EAAEF,CAAC,CAAC;MACvE;IACF;IAEA,IAAI,CAACZ,GAAG,GAAGA,GAAG;IACda,OAAO,CAACE,GAAG,CAAC,0CAA0Cf,GAAG,EAAE,CAAC;IAC5D,IAAI,CAACgB,sBAAsB,CAAC,YAAY,CAAC;IAEzC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF;QACA,IAAI,IAAI,CAAC9B,MAAM,EAAE;UACfwB,OAAO,CAACE,GAAG,CAAC,4CAA4C,CAAC;UACzD,IAAI,CAACK,UAAU,CAAC,CAAC;QACnB;QAEAP,OAAO,CAACE,GAAG,CAAC,kDAAkDf,GAAG,EAAE,CAAC;QACpE,IAAI,CAACX,MAAM,GAAG,IAAIoB,SAAS,CAACT,GAAG,CAAC;QAChC,IAAI,CAACgB,sBAAsB,CAAC,YAAY,CAAC;;QAEzC;QACA,IAAI,IAAI,CAACf,QAAQ,EAAE;UACjB,IAAI,CAACA,QAAQ,CAAC;YAAEoB,IAAI,EAAE,6BAA6B;YAAEC,OAAO,EAAE;cAAEC,MAAM,EAAE;YAAa;UAAE,CAAC,CAAC;QAC3F;;QAEA;QACA,IAAI,CAAClC,MAAM,CAACe,MAAM,GAAIoB,KAAK,IAAK;UAC9BX,OAAO,CAACE,GAAG,CAAC,oCAAoC,EAAE;YAChDf,GAAG,EAAE,IAAI,CAACX,MAAM,CAACW,GAAG;YACpByB,QAAQ,EAAE,IAAI,CAACpC,MAAM,CAACoC,QAAQ;YAC9BC,UAAU,EAAE,IAAI,CAACrC,MAAM,CAACqC,UAAU;YAClCC,UAAU,EAAE,IAAI,CAACtC,MAAM,CAACsC;UAC1B,CAAC,CAAC;UAEF,IAAI,CAAClC,iBAAiB,GAAG,CAAC;UAC1B,IAAI,CAACuB,sBAAsB,CAAC,WAAW,CAAC;UACxC,IAAI,CAACY,sBAAsB,CAAC,WAAW,CAAC;;UAExC;UACA,IAAI;YACF,MAAMC,WAAW,GAAGC,IAAI,CAACC,SAAS,CAAC;cACjCV,IAAI,EAAE,MAAM;cACZW,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;cACnCC,MAAM,EAAE;YACV,CAAC,CAAC;YACF,IAAI,CAAC9C,MAAM,CAAC+C,IAAI,CAACP,WAAW,CAAC;YAC7BhB,OAAO,CAACwB,KAAK,CAAC,+BAA+B,CAAC;UAChD,CAAC,CAAC,OAAOzB,CAAC,EAAE;YACVC,OAAO,CAACC,IAAI,CAAC,0CAA0C,EAAEF,CAAC,CAAC;UAC7D;UAEAM,OAAO,CAAC,CAAC;QACX,CAAC;QAED,IAAI,CAAC7B,MAAM,CAACiB,OAAO,GAAIgC,KAAK,IAAK;UAC/B,MAAMC,SAAS,GAAG;YAChBC,OAAO,EAAEF,KAAK,CAACE,OAAO,IAAI,yBAAyB;YACnDnB,IAAI,EAAEiB,KAAK,CAACjB,IAAI,IAAI,SAAS;YAC7Bb,UAAU,EAAE,IAAI,CAACnB,MAAM,GAAG,IAAI,CAACA,MAAM,CAACmB,UAAU,GAAG,WAAW;YAC9DR,GAAG,EAAE,IAAI,CAACA,GAAG;YACbgC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;UACpC,CAAC;UAEDrB,OAAO,CAACyB,KAAK,CAAC,+BAA+B,EAAEC,SAAS,CAAC;UACzD,IAAI,CAACvB,sBAAsB,CAAC,OAAO,CAAC;UACpC,IAAI,CAACyB,mBAAmB,CAAC,IAAIC,KAAK,CAACH,SAAS,CAACC,OAAO,CAAC,CAAC;;UAEtD;UACA,IAAI,IAAI,CAAC/C,iBAAiB,KAAK,CAAC,EAAE;YAChC,MAAMkD,OAAO,GAAG,IAAID,KAAK,CAAC,oBAAoBH,SAAS,CAACC,OAAO,EAAE,CAAC;YAClEG,OAAO,CAACC,OAAO,GAAGL,SAAS;YAC3B1B,OAAO,CAACyB,KAAK,CAAC,0CAA0C,EAAEK,OAAO,CAAC;YAClExB,MAAM,CAACwB,OAAO,CAAC;UACjB;QACF,CAAC;QAED,IAAI,CAACtD,MAAM,CAACgB,SAAS,GAAImB,KAAK,IAAK;UACjC,IAAI;YACF,MAAMgB,OAAO,GAAGhB,KAAK,CAACqB,IAAI;YAE1B,IAAI,CAACL,OAAO,EAAE;cACZ3B,OAAO,CAACwB,KAAK,CAAC,8CAA8C,CAAC;cAC7D;YACF;;YAEA;YACA,IAAIS,UAAU;YACd,IAAI,OAAON,OAAO,KAAK,QAAQ,EAAE;cAC/B,IAAI;gBACFM,UAAU,GAAGhB,IAAI,CAACiB,KAAK,CAACP,OAAO,CAAC;cAClC,CAAC,CAAC,OAAOQ,UAAU,EAAE;gBACnBnC,OAAO,CAACwB,KAAK,CAAC,wCAAwC,EAAEG,OAAO,CAAC;gBAChE,OAAO,CAAC;cACV;YACF,CAAC,MAAM,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;cACtCM,UAAU,GAAGN,OAAO,CAAC,CAAC;YACxB,CAAC,MAAM;cACL3B,OAAO,CAACwB,KAAK,CAAC,qDAAqD,EAAE,OAAOG,OAAO,CAAC;cACpF;YACF;YAEA3B,OAAO,CAACwB,KAAK,CAAC,iCAAiC,EAAES,UAAU,CAAC;YAC5D,IAAI,CAACG,cAAc,CAACH,UAAU,CAAC;UAEjC,CAAC,CAAC,OAAOR,KAAK,EAAE;YACdzB,OAAO,CAACyB,KAAK,CAAC,yCAAyC,EAAE;cACvDA,KAAK,EAAEA,KAAK,CAACE,OAAO;cACpBU,KAAK,EAAEZ,KAAK,CAACY,KAAK;cAClBC,OAAO,EAAE3B,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEqB;YAClB,CAAC,CAAC;YACF,IAAI,CAACJ,mBAAmB,CAACH,KAAK,CAAC;UACjC;QACF,CAAC;QAED,IAAI,CAACjD,MAAM,CAACkB,OAAO,GAAIiB,KAAK,IAAK;UAC/BX,OAAO,CAACE,GAAG,CAAC,+BAA+B,EAAE;YAC3CqC,IAAI,EAAE5B,KAAK,CAAC4B,IAAI;YAChBC,MAAM,EAAE7B,KAAK,CAAC6B,MAAM;YACpBC,QAAQ,EAAE9B,KAAK,CAAC8B;UAClB,CAAC,CAAC;UAEF,MAAMC,SAAS,GAAG,cAAc;UAChC,IAAI,CAACvC,sBAAsB,CAACuC,SAAS,CAAC;;UAEtC;UACA,IAAI,IAAI,CAACtD,QAAQ,EAAE;YACjB,IAAI,CAACA,QAAQ,CAAC;cAAEoB,IAAI,EAAE,6BAA6B;cAAEC,OAAO,EAAE;gBAAEC,MAAM,EAAEgC;cAAU;YAAE,CAAC,CAAC;UACxF;UAEA,IAAI,CAACC,gBAAgB,CAAC,CAAC;QACzB,CAAC;MACH,CAAC,CAAC,OAAOlB,KAAK,EAAE;QACdzB,OAAO,CAACyB,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;QACnDnB,MAAM,CAACmB,KAAK,CAAC;MACf;IACF,CAAC,CAAC;EACJ;EAEAtB,sBAAsBA,CAACO,MAAM,EAAE;IAC7B,IAAI,CAAC1B,gBAAgB,GAAG0B,MAAM;IAC9B,IAAI,CAACkC,kBAAkB,CAAClC,MAAM,CAAC;EACjC;EAEAmC,cAAcA,CAACC,QAAQ,EAAE;IACvB,IAAI,CAAC7D,yBAAyB,CAAC8D,GAAG,CAACD,QAAQ,CAAC;IAC5C,OAAO,MAAM,IAAI,CAAC7D,yBAAyB,CAAC+D,MAAM,CAACF,QAAQ,CAAC;EAC9D;EAEAF,kBAAkBA,CAAClC,MAAM,EAAE;IACzB,IAAI,CAACzB,yBAAyB,CAACgE,OAAO,CAACH,QAAQ,IAAI;MACjD,IAAI;QACFA,QAAQ,CAACpC,MAAM,CAAC;MAClB,CAAC,CAAC,OAAOe,KAAK,EAAE;QACdzB,OAAO,CAACyB,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACzD;IACF,CAAC,CAAC;EACJ;EAEAyB,SAASA,CAAA,EAAG;IACV,OAAO,IAAI,CAAClE,gBAAgB;EAC9B;EAEAuB,UAAUA,CAAA,EAAG;IACX,IAAI,IAAI,CAAC/B,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAACsB,KAAK,CAAC,CAAC;MACnB,IAAI,CAACtB,MAAM,GAAG,IAAI;IACpB;IACA,IAAI,CAACC,eAAe,CAAC0E,KAAK,CAAC,CAAC;EAC9B;EAEA5B,IAAIA,CAACI,OAAO,EAAE;IACZ,IAAI,IAAI,CAACnD,MAAM,IAAI,IAAI,CAACA,MAAM,CAACmB,UAAU,KAAKC,SAAS,CAACC,IAAI,EAAE;MAC5D,IAAI;QACF,MAAMuD,aAAa,GAAG,OAAOzB,OAAO,KAAK,QAAQ,GAAGA,OAAO,GAAGV,IAAI,CAACC,SAAS,CAACS,OAAO,CAAC;QACrF,IAAI,CAACnD,MAAM,CAAC+C,IAAI,CAAC6B,aAAa,CAAC;QAC/B,OAAO,IAAI;MACb,CAAC,CAAC,OAAO3B,KAAK,EAAE;QACdzB,OAAO,CAACyB,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;QACxD,OAAO,KAAK;MACd;IACF;IACAzB,OAAO,CAACC,IAAI,CAAC,4BAA4B,CAAC;IAC1C,OAAO,KAAK;EACd;EAEAoD,iBAAiBA,CAACC,OAAO,EAAE;IACzB,IAAI,CAAC7E,eAAe,CAACsE,GAAG,CAACO,OAAO,CAAC;;IAEjC;IACA,OAAO,MAAM,IAAI,CAAC7E,eAAe,CAACuE,MAAM,CAACM,OAAO,CAAC;EACnD;EAEAC,oBAAoBA,CAACD,OAAO,EAAE;IAC5B,IAAI,CAAC7E,eAAe,CAACuE,MAAM,CAACM,OAAO,CAAC;EACtC;EAEAlB,cAAcA,CAACJ,IAAI,EAAE;IACnB,IAAI,CAACA,IAAI,EAAE;MACThC,OAAO,CAACC,IAAI,CAAC,gDAAgD,CAAC;MAC9D;IACF;IAEAD,OAAO,CAACwB,KAAK,CAAC,sCAAsC,EAAEQ,IAAI,CAAC;IAE3D,IAAI;MACF;MACA,IAAI,CAACvD,eAAe,CAACwE,OAAO,CAACK,OAAO,IAAI;QACtC,IAAI;UACF,IAAI,OAAOA,OAAO,KAAK,UAAU,EAAE;YACjCA,OAAO,CAACtB,IAAI,CAAC;UACf;QACF,CAAC,CAAC,OAAOP,KAAK,EAAE;UACdzB,OAAO,CAACyB,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;QAC/D;MACF,CAAC,CAAC;;MAEF;MACA,IAAI,IAAI,CAACrC,QAAQ,EAAE;QACjB;QACA,IAAI4C,IAAI,CAACxB,IAAI,EAAE;UACb;UACA,IAAIwB,IAAI,CAACxB,IAAI,KAAK,QAAQ,IAAIwB,IAAI,CAACA,IAAI,EAAE;YACvC,IAAI,CAAC5C,QAAQ,CAAC;cACZoB,IAAI,EAAE,mBAAmB;cACzBC,OAAO,EAAEuB,IAAI,CAACA;YAChB,CAAC,CAAC;UACJ,CAAC,MAAM,IAAIA,IAAI,CAACxB,IAAI,KAAK,QAAQ,EAAE;YACjC,IAAI,CAACpB,QAAQ,CAAC;cACZoB,IAAI,EAAE,6BAA6B;cACnCC,OAAO,EAAEuB,IAAI,CAACA,IAAI,IAAIA;YACxB,CAAC,CAAC;UACJ,CAAC,MAAM,IAAIA,IAAI,CAACxB,IAAI,KAAK,YAAY,EAAE;YACrC,IAAI,CAACpB,QAAQ,CAAC;cACZoB,IAAI,EAAE,0BAA0B;cAChCC,OAAO,EAAEuB,IAAI,CAACA,IAAI,IAAIA;YACxB,CAAC,CAAC;UACJ,CAAC,MAAM,IAAIA,IAAI,CAACxB,IAAI,KAAK,OAAO,EAAE;YAChC,IAAI,CAACpB,QAAQ,CAAC;cACZoB,IAAI,EAAE,qBAAqB;cAC3BC,OAAO,EAAEuB,IAAI,CAACA,IAAI,IAAIA;YACxB,CAAC,CAAC;UACJ,CAAC,MAAM,IAAIA,IAAI,CAACxB,IAAI,KAAK,WAAW,EAAE;YACpC,IAAI,CAACpB,QAAQ,CAAC;cACZoB,IAAI,EAAE,yBAAyB;cAC/BC,OAAO,EAAEuB,IAAI,CAACA,IAAI,IAAIA;YACxB,CAAC,CAAC;UACJ;QACF,CAAC,MAAM,IAAIA,IAAI,CAACpB,QAAQ,EAAE;UACxB;UACA,IAAI,CAACxB,QAAQ,CAAC;YACZoB,IAAI,EAAE,mBAAmB;YACzBC,OAAO,EAAEuB;UACX,CAAC,CAAC;QACJ,CAAC,MAAM,IAAIA,IAAI,CAACwB,WAAW,KAAKC,SAAS,EAAE;UACzC;UACA,IAAI,CAACrE,QAAQ,CAAC;YACZoB,IAAI,EAAE,6BAA6B;YACnCC,OAAO,EAAEuB;UACX,CAAC,CAAC;QACJ;MACF;IACF,CAAC,CAAC,OAAOP,KAAK,EAAE;MACdzB,OAAO,CAACyB,KAAK,CAAC,qCAAqC,EAAE;QACnDA,KAAK,EAAEA,KAAK,CAACE,OAAO;QACpBU,KAAK,EAAEZ,KAAK,CAACY,KAAK;QAClBV,OAAO,EAAEA,OAAO;QAChBM,UAAU,EAAED;MACd,CAAC,CAAC;IACJ;EACF;EAEA0B,OAAOA,CAACJ,OAAO,EAAE;IACf,IAAI,OAAOA,OAAO,KAAK,UAAU,EAAE;MACjC,IAAI,CAAC3E,aAAa,CAACoE,GAAG,CAACO,OAAO,CAAC;MAC/B,OAAO,MAAM,IAAI,CAAC3E,aAAa,CAACqE,MAAM,CAACM,OAAO,CAAC;IACjD;IACA,OAAO,MAAM,CAAE,CAAC;EAClB;EAEAK,kBAAkBA,CAACL,OAAO,EAAE;IAC1B,IAAI,CAAC3E,aAAa,CAACqE,MAAM,CAACM,OAAO,CAAC;EACpC;EAEA1B,mBAAmBA,CAACH,KAAK,EAAE;IACzB,IAAI,CAAC9C,aAAa,CAACsE,OAAO,CAACK,OAAO,IAAI;MACpC,IAAI;QACFA,OAAO,CAAC7B,KAAK,CAAC;MAChB,CAAC,CAAC,OAAOmC,GAAG,EAAE;QACZ5D,OAAO,CAACyB,KAAK,CAAC,yBAAyB,EAAEmC,GAAG,CAAC;MAC/C;IACF,CAAC,CAAC;EACJ;EAEAjB,gBAAgBA,CAAA,EAAG;IACjB,IAAI,CAAC/D,iBAAiB,EAAE;IACxB,IAAI,CAACE,cAAc,GAAG+E,IAAI,CAACC,GAAG,CAAC,IAAI,CAAChF,cAAc,GAAG,CAAC,EAAE,IAAI,CAACC,iBAAiB,CAAC;IAC/E,IAAI,CAACG,gBAAgB,GAAG6E,UAAU,CAAC,MAAM;MACvC,IAAI,CAACzE,OAAO,CAAC,IAAI,CAACH,GAAG,CAAC;IACxB,CAAC,EAAE,IAAI,CAACL,cAAc,CAAC;EACzB;AACF;;AAEA;AACA,OAAO,MAAMkF,gBAAgB,GAAG,IAAI1F,gBAAgB,CAAC,CAAC;;AAEtD;AACA,OAAO,MAAM2F,YAAY,GAAGA,CAACC,SAAS,EAAEC,YAAY,GAAG,EAAE,KAAK;EAAAC,EAAA;EAC5D,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGnG,KAAK,CAACE,QAAQ,CAAC,KAAK,CAAC;EAC3D,MAAM,CAACoD,KAAK,EAAE8C,QAAQ,CAAC,GAAGpG,KAAK,CAACE,QAAQ,CAAC,IAAI,CAAC;EAE9CF,KAAK,CAACC,SAAS,CAAC,MAAM;IACpB,MAAMoG,aAAa,GAAI7C,OAAO,IAAK;MACjC,IAAIA,OAAO,CAACnB,IAAI,KAAK,wBAAwB,EAAE;QAC7C8D,cAAc,CAAC,IAAI,CAAC;QACpBC,QAAQ,CAAC,IAAI,CAAC;MAChB,CAAC,MAAM,IAAI5C,OAAO,CAACnB,IAAI,KAAK,kBAAkB,EAAE;QAC9C+D,QAAQ,CAAC5C,OAAO,CAAClB,OAAO,CAAC;MAC3B;MAEA,IAAIyD,SAAS,EAAE;QACbA,SAAS,CAACvC,OAAO,CAAC;MACpB;IACF,CAAC;;IAED;IACA,MAAM8C,aAAa,GAAGT,gBAAgB,CAACX,iBAAiB,CAACmB,aAAa,CAAC;;IAEvE;IACA,OAAO,MAAM;MACXC,aAAa,CAAC,CAAC;IACjB,CAAC;EACH,CAAC,EAAE,CAACP,SAAS,EAAE,GAAGC,YAAY,CAAC,CAAC;AAClC,CAAC;AAACC,EAAA,CA1BWH,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}