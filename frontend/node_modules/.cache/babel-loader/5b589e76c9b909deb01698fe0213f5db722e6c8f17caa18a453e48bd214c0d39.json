{"ast":null,"code":"import _objectSpread from\"C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{createSlice,createAsyncThunk}from'@reduxjs/toolkit';import{webSocketService}from'../../services/websocketService';// WebSocket server URL (should be moved to environment variables in production)\nconst WS_URL=process.env.REACT_APP_WS_URL||'ws://localhost:8080/ws';const initialState={status:'disconnected',// 'disconnected', 'connecting', 'connected', 'error'\nerror:null,interfaces:[],activeInterface:null,isCapturing:false,packets:[],stats:{total:0,tcp:0,udp:0,http:0,https:0,dns:0,other:0,dropped:0},bandwidth:{in:0,out:0,history:[],lastUpdate:null},filters:{protocol:'all',sourceIp:'',destinationIp:'',port:''},selectedPacket:null};// Thunks for WebSocket operations\nexport const connectToCapture=createAsyncThunk('network/connectToCapture',async(_,_ref)=>{let{dispatch,getState}=_ref;try{const{activeInterface}=getState().network;if(!activeInterface){throw new Error('No network interface selected');}// Connect to WebSocket server\nawait webSocketService.connect(WS_URL);// Set up message handler\nwebSocketService.addMessageHandler(message=>{switch(message.type){case'packet':dispatch(addPacket(message.payload));break;case'stats/update':dispatch(updateStats(message.payload));break;case'bandwidth/update':dispatch(updateBandwidth(message.payload));break;case'interfaces/update':dispatch(updateInterfaces(message.payload));break;case'error':console.error('WebSocket Error:',message.payload);break;default:console.log('Unhandled message type:',message.type);}});// Request initial data\nwebSocketService.sendMessage({type:'interfaces/list'});return{status:'connected'};}catch(error){console.error('WebSocket connection failed:',error);return{error:error.message};}});export const startCapture=createAsyncThunk('network/startCapture',async(_,_ref2)=>{let{getState}=_ref2;const{activeInterface}=getState().network;if(!activeInterface){throw new Error('No network interface selected');}const success=webSocketService.startCapture(activeInterface);if(!success){throw new Error('Failed to send start capture command');}return{success:true};});export const stopCapture=createAsyncThunk('network/stopCapture',async()=>{const success=webSocketService.stopCapture();if(!success){throw new Error('Failed to send stop capture command');}return{success:true};});export const updateCaptureFilter=createAsyncThunk('network/updateCaptureFilter',async(filter,_ref3)=>{let{getState}=_ref3;const success=webSocketService.setFilter(filter);if(!success){throw new Error('Failed to update capture filter');}return{filter};});const networkSlice=createSlice({name:'network',initialState,reducers:{setActiveInterface:(state,action)=>{state.activeInterface=action.payload;// When interface changes, clear existing packets\nstate.packets=[];state.stats={total:0,tcp:0,udp:0,http:0,https:0,dns:0,other:0,dropped:0};},addPacket:(state,action)=>{const packet=action.payload;packet.timestamp=packet.timestamp||new Date().toISOString();state.packets.unshift(packet);// Keep only the last 1000 packets for performance\nif(state.packets.length>1000){state.packets.pop();}},updateStats:(state,action)=>{state.stats=_objectSpread(_objectSpread({},state.stats),action.payload);},updateBandwidth:(state,action)=>{const{in:inBytes,out:outBytes}=action.payload;const now=new Date().toISOString();state.bandwidth.in=inBytes;state.bandwidth.out=outBytes;state.bandwidth.history.push({timestamp:now,in:inBytes,out:outBytes});// Keep only the last 60 data points (1 minute at 1s intervals)\nif(state.bandwidth.history.length>60){state.bandwidth.history.shift();}state.bandwidth.lastUpdate=now;},updateInterfaces:(state,action)=>{state.interfaces=action.payload;if(action.payload.length>0&&!state.activeInterface){state.activeInterface=action.payload[0].name;}},setFilter:(state,action)=>{state.filters=_objectSpread(_objectSpread({},state.filters),action.payload);},selectPacket:(state,action)=>{state.selectedPacket=action.payload;},clearPackets:state=>{state.packets=[];state.stats={total:0,tcp:0,udp:0,http:0,https:0,dns:0,other:0,dropped:0};}},extraReducers:builder=>{builder.addCase(connectToCapture.pending,state=>{state.status='connecting';}).addCase(connectToCapture.fulfilled,(state,action)=>{if(action.payload.error){state.status='error';state.error=action.payload.error;}else{state.status='connected';}}).addCase(connectToCapture.rejected,(state,action)=>{state.status='error';state.error=action.error.message;}).addCase(startCapture.pending,state=>{state.isCapturing=true;}).addCase(startCapture.fulfilled,state=>{state.isCapturing=true;}).addCase(startCapture.rejected,(state,action)=>{state.isCapturing=false;state.error=action.error.message;});}});export const{setActiveInterface,addPacket,updateStats,updateBandwidth,updateInterfaces,setFilter,selectPacket,clearPackets}=networkSlice.actions;export default networkSlice.reducer;// Selectors\nexport const selectNetworkStatus=state=>state.network.status;export const selectInterfaces=state=>state.network.interfaces;export const selectActiveInterface=state=>state.network.activeInterface;export const selectIsCapturing=state=>state.network.isCapturing;export const selectPackets=state=>state.network.packets;export const selectStats=state=>state.network.stats;export const selectBandwidth=state=>state.network.bandwidth;export const selectFilters=state=>state.network.filters;export const selectSelectedPacket=state=>state.network.selectedPacket;export const selectFilteredPackets=state=>{const{packets}=state.network;const{protocol,sourceIp,destinationIp,port}=state.network.filters;return packets.filter(packet=>{var _packet$protocol,_packet$source,_packet$destination;// Filter by protocol\nif(protocol!=='all'&&((_packet$protocol=packet.protocol)===null||_packet$protocol===void 0?void 0:_packet$protocol.toLowerCase())!==protocol){return false;}// Filter by source IP\nif(sourceIp&&!((_packet$source=packet.source)!==null&&_packet$source!==void 0&&_packet$source.includes(sourceIp))){return false;}// Filter by destination IP\nif(destinationIp&&!((_packet$destination=packet.destination)!==null&&_packet$destination!==void 0&&_packet$destination.includes(destinationIp))){return false;}// Filter by port\nif(port&&!\"\".concat(packet.sourcePort||'').concat(packet.destinationPort||'').includes(port)){return false;}return true;});};// These actions are already exported from createAsyncThunk above","map":{"version":3,"names":["createSlice","createAsyncThunk","webSocketService","WS_URL","process","env","REACT_APP_WS_URL","initialState","status","error","interfaces","activeInterface","isCapturing","packets","stats","total","tcp","udp","http","https","dns","other","dropped","bandwidth","in","out","history","lastUpdate","filters","protocol","sourceIp","destinationIp","port","selectedPacket","connectToCapture","_","_ref","dispatch","getState","network","Error","connect","addMessageHandler","message","type","addPacket","payload","updateStats","updateBandwidth","updateInterfaces","console","log","sendMessage","startCapture","_ref2","success","stopCapture","updateCaptureFilter","filter","_ref3","setFilter","networkSlice","name","reducers","setActiveInterface","state","action","packet","timestamp","Date","toISOString","unshift","length","pop","_objectSpread","inBytes","outBytes","now","push","shift","selectPacket","clearPackets","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","reducer","selectNetworkStatus","selectInterfaces","selectActiveInterface","selectIsCapturing","selectPackets","selectStats","selectBandwidth","selectFilters","selectSelectedPacket","selectFilteredPackets","_packet$protocol","_packet$source","_packet$destination","toLowerCase","source","includes","destination","concat","sourcePort","destinationPort"],"sources":["C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/src/features/network/networkSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { webSocketService } from '../../services/websocketService';\n\n// WebSocket server URL (should be moved to environment variables in production)\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8080/ws';\n\nconst initialState = {\n  status: 'disconnected', // 'disconnected', 'connecting', 'connected', 'error'\n  error: null,\n  interfaces: [],\n  activeInterface: null,\n  isCapturing: false,\n  packets: [],\n  stats: {\n    total: 0,\n    tcp: 0,\n    udp: 0,\n    http: 0,\n    https: 0,\n    dns: 0,\n    other: 0,\n    dropped: 0,\n  },\n  bandwidth: {\n    in: 0,\n    out: 0,\n    history: [],\n    lastUpdate: null,\n  },\n  filters: {\n    protocol: 'all',\n    sourceIp: '',\n    destinationIp: '',\n    port: '',\n  },\n  selectedPacket: null,\n};\n\n// Thunks for WebSocket operations\nexport const connectToCapture = createAsyncThunk(\n  'network/connectToCapture',\n  async (_, { dispatch, getState }) => {\n    try {\n      const { activeInterface } = getState().network;\n      if (!activeInterface) {\n        throw new Error('No network interface selected');\n      }\n\n      // Connect to WebSocket server\n      await webSocketService.connect(WS_URL);\n      \n      // Set up message handler\n      webSocketService.addMessageHandler((message) => {\n        switch (message.type) {\n          case 'packet':\n            dispatch(addPacket(message.payload));\n            break;\n          case 'stats/update':\n            dispatch(updateStats(message.payload));\n            break;\n          case 'bandwidth/update':\n            dispatch(updateBandwidth(message.payload));\n            break;\n          case 'interfaces/update':\n            dispatch(updateInterfaces(message.payload));\n            break;\n          case 'error':\n            console.error('WebSocket Error:', message.payload);\n            break;\n          default:\n            console.log('Unhandled message type:', message.type);\n        }\n      });\n\n      // Request initial data\n      webSocketService.sendMessage({ type: 'interfaces/list' });\n      \n      return { status: 'connected' };\n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n      return { error: error.message };\n    }\n  }\n);\n\nexport const startCapture = createAsyncThunk(\n  'network/startCapture',\n  async (_, { getState }) => {\n    const { activeInterface } = getState().network;\n    if (!activeInterface) {\n      throw new Error('No network interface selected');\n    }\n    \n    const success = webSocketService.startCapture(activeInterface);\n    if (!success) {\n      throw new Error('Failed to send start capture command');\n    }\n    return { success: true };\n  }\n);\n\nexport const stopCapture = createAsyncThunk(\n  'network/stopCapture',\n  async () => {\n    const success = webSocketService.stopCapture();\n    if (!success) {\n      throw new Error('Failed to send stop capture command');\n    }\n    return { success: true };\n  }\n);\n\nexport const updateCaptureFilter = createAsyncThunk(\n  'network/updateCaptureFilter',\n  async (filter, { getState }) => {\n    const success = webSocketService.setFilter(filter);\n    if (!success) {\n      throw new Error('Failed to update capture filter');\n    }\n    return { filter };\n  }\n);\n\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setActiveInterface: (state, action) => {\n      state.activeInterface = action.payload;\n      // When interface changes, clear existing packets\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0,\n      };\n    },\n    addPacket: (state, action) => {\n      const packet = action.payload;\n      packet.timestamp = packet.timestamp || new Date().toISOString();\n      state.packets.unshift(packet);\n      \n      // Keep only the last 1000 packets for performance\n      if (state.packets.length > 1000) {\n        state.packets.pop();\n      }\n    },\n    updateStats: (state, action) => {\n      state.stats = { ...state.stats, ...action.payload };\n    },\n    updateBandwidth: (state, action) => {\n      const { in: inBytes, out: outBytes } = action.payload;\n      const now = new Date().toISOString();\n      \n      state.bandwidth.in = inBytes;\n      state.bandwidth.out = outBytes;\n      state.bandwidth.history.push({\n        timestamp: now,\n        in: inBytes,\n        out: outBytes\n      });\n      \n      // Keep only the last 60 data points (1 minute at 1s intervals)\n      if (state.bandwidth.history.length > 60) {\n        state.bandwidth.history.shift();\n      }\n      \n      state.bandwidth.lastUpdate = now;\n    },\n    updateInterfaces: (state, action) => {\n      state.interfaces = action.payload;\n      if (action.payload.length > 0 && !state.activeInterface) {\n        state.activeInterface = action.payload[0].name;\n      }\n    },\n    setFilter: (state, action) => {\n      state.filters = { ...state.filters, ...action.payload };\n    },\n    selectPacket: (state, action) => {\n      state.selectedPacket = action.payload;\n    },\n    clearPackets: (state) => {\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0,\n      };\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(connectToCapture.pending, (state) => {\n        state.status = 'connecting';\n      })\n      .addCase(connectToCapture.fulfilled, (state, action) => {\n        if (action.payload.error) {\n          state.status = 'error';\n          state.error = action.payload.error;\n        } else {\n          state.status = 'connected';\n        }\n      })\n      .addCase(connectToCapture.rejected, (state, action) => {\n        state.status = 'error';\n        state.error = action.error.message;\n      })\n      .addCase(startCapture.pending, (state) => {\n        state.isCapturing = true;\n      })\n      .addCase(startCapture.fulfilled, (state) => {\n        state.isCapturing = true;\n      })\n      .addCase(startCapture.rejected, (state, action) => {\n        state.isCapturing = false;\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport const {\n  setActiveInterface,\n  addPacket,\n  updateStats,\n  updateBandwidth,\n  updateInterfaces,\n  setFilter,\n  selectPacket,\n  clearPackets,\n} = networkSlice.actions;\n\nexport default networkSlice.reducer;\n\n// Selectors\nexport const selectNetworkStatus = (state) => state.network.status;\nexport const selectInterfaces = (state) => state.network.interfaces;\nexport const selectActiveInterface = (state) => state.network.activeInterface;\nexport const selectIsCapturing = (state) => state.network.isCapturing;\nexport const selectPackets = (state) => state.network.packets;\nexport const selectStats = (state) => state.network.stats;\nexport const selectBandwidth = (state) => state.network.bandwidth;\nexport const selectFilters = (state) => state.network.filters;\nexport const selectSelectedPacket = (state) => state.network.selectedPacket;\n\nexport const selectFilteredPackets = (state) => {\n  const { packets } = state.network;\n  const { protocol, sourceIp, destinationIp, port } = state.network.filters;\n  \n  return packets.filter(packet => {\n    // Filter by protocol\n    if (protocol !== 'all' && packet.protocol?.toLowerCase() !== protocol) {\n      return false;\n    }\n    \n    // Filter by source IP\n    if (sourceIp && !packet.source?.includes(sourceIp)) {\n      return false;\n    }\n    \n    // Filter by destination IP\n    if (destinationIp && !packet.destination?.includes(destinationIp)) {\n      return false;\n    }\n    \n    // Filter by port\n    if (port && !`${packet.sourcePort || ''}${packet.destinationPort || ''}`.includes(port)) {\n      return false;\n    }\n    \n    return true;\n  });\n};\n\n// These actions are already exported from createAsyncThunk above\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}