{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { webSocketService } from './websocketService';\n\n// Helper function to safely access nested object properties\nconst safeGet = (obj, path, defaultValue = null) => {\n  return path.split('.').reduce((acc, key) => acc && acc[key] !== undefined ? acc[key] : defaultValue, obj);\n};\n\n// Default state with comprehensive defaults\nconst initialState = {\n  isConnected: false,\n  isCapturing: false,\n  interfaces: [],\n  currentInterface: null,\n  packets: [],\n  stats: {\n    packetCount: 0,\n    protocols: {\n      tcp: 0,\n      udp: 0,\n      icmp: 0,\n      other: 0\n    },\n    sourceIps: {},\n    destinationIps: {}\n  },\n  bandwidth: {\n    bpsReceived: 0,\n    bpsSent: 0,\n    totalReceived: 0,\n    totalSent: 0,\n    lastUpdated: null\n  },\n  detectedAttacks: [],\n  activeMitigations: {},\n  error: null,\n  lastUpdated: null\n};\n\n// Async thunks\nexport const connectToBackend = createAsyncThunk('network/connect', async (_, {\n  dispatch\n}) => {\n  try {\n    const wsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8080';\n    await webSocketService.connect(wsUrl);\n\n    // Set up message handler\n    const messageHandler = message => {\n      switch (message.type) {\n        case 'init':\n          dispatch(setInterfaces(message.interfaces));\n          dispatch(setIsCapturing(message.is_capturing));\n          dispatch(setCurrentInterface(message.current_interface));\n          break;\n        case 'status':\n          dispatch(updateStats(message.stats));\n          dispatch(setBandwidth(message.bandwidth));\n          dispatch(setIsCapturing(message.is_capturing));\n          dispatch(setCurrentInterface(message.current_interface));\n          dispatch(updateMitigations(message.active_mitigations));\n          break;\n        case 'packet':\n          dispatch(addPacket(message.packet));\n          break;\n        case 'attack_detected':\n          dispatch(addDetectedAttack(message.attack));\n          break;\n        case 'mitigation_update':\n          dispatch(updateMitigations(message.active_mitigations));\n          break;\n        default:\n          console.warn('Unknown message type:', message.type);\n      }\n    };\n\n    // Add message handler\n    webSocketService.onMessage(messageHandler);\n\n    // Return cleanup function\n    return () => {\n      webSocketService.removeMessageHandler(messageHandler);\n    };\n  } catch (error) {\n    console.error('Failed to connect to backend:', error);\n    throw error;\n  }\n});\nexport const startCapture = createAsyncThunk('network/startCapture', async (interfaceName, {\n  getState\n}) => {\n  await webSocketService.sendMessage({\n    type: 'start_capture',\n    interface: interfaceName\n  });\n  return {\n    interface: interfaceName\n  };\n});\nexport const stopCapture = createAsyncThunk('network/stopCapture', async () => {\n  await webSocketService.sendMessage({\n    type: 'stop_capture'\n  });\n  return {\n    isCapturing: false\n  };\n});\nexport const applyMitigation = createAsyncThunk('network/applyMitigation', async ({\n  target,\n  action\n}, {\n  dispatch\n}) => {\n  await webSocketService.sendMessage({\n    type: 'mitigate',\n    target,\n    action\n  });\n  return {\n    target,\n    action\n  };\n});\nexport const reconnect = createAsyncThunk('network/reconnect', async () => {\n  await webSocketService.connect('ws://localhost:8080');\n  return {\n    reconnecting: false\n  };\n});\n\n// Slice\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setInterfaces: (state, action) => {\n      state.interfaces = Array.isArray(action.payload) ? action.payload : [];\n      state.lastUpdated = new Date().toISOString();\n    },\n    setIsCapturing: (state, action) => {\n      state.isCapturing = Boolean(action.payload);\n      state.lastUpdated = new Date().toISOString();\n    },\n    setCurrentInterface: (state, action) => {\n      state.currentInterface = action.payload || null;\n      state.lastUpdated = new Date().toISOString();\n    },\n    addPacket: (state, action) => {\n      const packet = action.payload || {};\n      // Ensure packet has required fields\n      if (packet.timestamp && (packet.src || packet.dst)) {\n        state.packets.unshift({\n          ...packet,\n          protocol: packet.protocol || 'unknown',\n          length: packet.length || 0,\n          info: packet.info || {},\n          timestamp: packet.timestamp || new Date().toISOString()\n        });\n\n        // Limit packet history\n        if (state.packets.length > 1000) {\n          state.packets.pop();\n        }\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    updateStats: (state, action) => {\n      if (action.payload) {\n        var _action$payload$proto, _action$payload$proto2, _action$payload$proto3, _action$payload$proto4;\n        state.stats = {\n          packetCount: Number(action.payload.packetCount) || state.stats.packetCount,\n          protocols: {\n            tcp: Number((_action$payload$proto = action.payload.protocols) === null || _action$payload$proto === void 0 ? void 0 : _action$payload$proto.tcp) || state.stats.protocols.tcp,\n            udp: Number((_action$payload$proto2 = action.payload.protocols) === null || _action$payload$proto2 === void 0 ? void 0 : _action$payload$proto2.udp) || state.stats.protocols.udp,\n            icmp: Number((_action$payload$proto3 = action.payload.protocols) === null || _action$payload$proto3 === void 0 ? void 0 : _action$payload$proto3.icmp) || state.stats.protocols.icmp,\n            other: Number((_action$payload$proto4 = action.payload.protocols) === null || _action$payload$proto4 === void 0 ? void 0 : _action$payload$proto4.other) || state.stats.protocols.other\n          },\n          sourceIps: action.payload.sourceIps || state.stats.sourceIps,\n          destinationIps: action.payload.destinationIps || state.stats.destinationIps\n        };\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    setBandwidth: (state, action) => {\n      if (action.payload) {\n        state.bandwidth = {\n          bpsReceived: Number(action.payload.bpsReceived) || 0,\n          bpsSent: Number(action.payload.bpsSent) || 0,\n          totalReceived: Number(action.payload.totalReceived) || 0,\n          totalSent: Number(action.payload.totalSent) || 0,\n          lastUpdated: new Date().toISOString()\n        };\n      }\n    },\n    addDetectedAttack: (state, action) => {\n      if (action.payload) {\n        state.detectedAttacks.unshift({\n          ...action.payload,\n          timestamp: action.payload.timestamp || new Date().toISOString()\n        });\n\n        // Limit attack history\n        if (state.detectedAttacks.length > 100) {\n          state.detectedAttacks.pop();\n        }\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    updateMitigations: (state, action) => {\n      if (action.payload && typeof action.payload === 'object') {\n        state.activeMitigations = {\n          ...state.activeMitigations,\n          ...action.payload\n        };\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    setError: (state, action) => {\n      state.error = action.payload;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(connectToBackend.fulfilled, state => {\n      state.isConnected = true;\n      state.error = null;\n    }).addCase(connectToBackend.rejected, (state, action) => {\n      state.isConnected = false;\n      state.error = action.error.message;\n    }).addCase(startCapture.fulfilled, (state, action) => {\n      state.isCapturing = true;\n      state.currentInterface = action.payload.interface;\n    }).addCase(stopCapture.fulfilled, state => {\n      state.isCapturing = false;\n    }).addCase(applyMitigation.fulfilled, (state, action) => {\n      const {\n        target,\n        action: mitigationAction\n      } = action.payload;\n      state.activeMitigations[target] = {\n        action: mitigationAction,\n        timestamp: new Date().toISOString(),\n        expires: new Date(Date.now() + 3600000).toISOString() // 1 hour from now\n      };\n    });\n  }\n});\n\n// Export actions\nexport const {\n  setInterfaces,\n  setIsCapturing,\n  setCurrentInterface,\n  addPacket,\n  updateStats,\n  setBandwidth,\n  addDetectedAttack,\n  updateMitigations,\n  setError\n} = networkSlice.actions;\n\n// Export selectors\nexport const selectIsConnected = state => state.network.isConnected;\nexport const selectIsCapturing = state => state.network.isCapturing;\nexport const selectInterfaces = state => state.network.interfaces;\nexport const selectCurrentInterface = state => state.network.currentInterface;\nexport const selectPackets = state => state.network.packets;\nexport const selectStats = state => state.network.stats;\nexport const selectBandwidth = state => state.network.bandwidth;\nexport const selectDetectedAttacks = state => state.network.detectedAttacks;\nexport const selectActiveMitigations = state => state.network.activeMitigations;\nexport const selectError = state => state.network.error;\nexport default networkSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","webSocketService","safeGet","obj","path","defaultValue","split","reduce","acc","key","undefined","initialState","isConnected","isCapturing","interfaces","currentInterface","packets","stats","packetCount","protocols","tcp","udp","icmp","other","sourceIps","destinationIps","bandwidth","bpsReceived","bpsSent","totalReceived","totalSent","lastUpdated","detectedAttacks","activeMitigations","error","connectToBackend","_","dispatch","wsUrl","process","env","REACT_APP_WS_URL","connect","messageHandler","message","type","setInterfaces","setIsCapturing","is_capturing","setCurrentInterface","current_interface","updateStats","setBandwidth","updateMitigations","active_mitigations","addPacket","packet","addDetectedAttack","attack","console","warn","onMessage","removeMessageHandler","startCapture","interfaceName","getState","sendMessage","interface","stopCapture","applyMitigation","target","action","reconnect","reconnecting","networkSlice","name","reducers","state","Array","isArray","payload","Date","toISOString","Boolean","timestamp","src","dst","unshift","protocol","length","info","pop","_action$payload$proto","_action$payload$proto2","_action$payload$proto3","_action$payload$proto4","Number","setError","extraReducers","builder","addCase","fulfilled","rejected","mitigationAction","expires","now","actions","selectIsConnected","network","selectIsCapturing","selectInterfaces","selectCurrentInterface","selectPackets","selectStats","selectBandwidth","selectDetectedAttacks","selectActiveMitigations","selectError","reducer"],"sources":["C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/src/services/networkService.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { webSocketService } from './websocketService';\n\n// Helper function to safely access nested object properties\nconst safeGet = (obj, path, defaultValue = null) => {\n  return path.split('.').reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : defaultValue), obj);\n};\n\n// Default state with comprehensive defaults\nconst initialState = {\n  isConnected: false,\n  isCapturing: false,\n  interfaces: [],\n  currentInterface: null,\n  packets: [],\n  stats: {\n    packetCount: 0,\n    protocols: {\n      tcp: 0,\n      udp: 0,\n      icmp: 0,\n      other: 0\n    },\n    sourceIps: {},\n    destinationIps: {}\n  },\n  bandwidth: {\n    bpsReceived: 0,\n    bpsSent: 0,\n    totalReceived: 0,\n    totalSent: 0,\n    lastUpdated: null\n  },\n  detectedAttacks: [],\n  activeMitigations: {},\n  error: null,\n  lastUpdated: null\n};\n\n// Async thunks\nexport const connectToBackend = createAsyncThunk(\n  'network/connect',\n  async (_, { dispatch }) => {\n    try {\n      const wsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8080';\n      await webSocketService.connect(wsUrl);\n      \n      // Set up message handler\n      const messageHandler = (message) => {\n        switch (message.type) {\n          case 'init':\n            dispatch(setInterfaces(message.interfaces));\n            dispatch(setIsCapturing(message.is_capturing));\n            dispatch(setCurrentInterface(message.current_interface));\n            break;\n            \n          case 'status':\n            dispatch(updateStats(message.stats));\n            dispatch(setBandwidth(message.bandwidth));\n            dispatch(setIsCapturing(message.is_capturing));\n            dispatch(setCurrentInterface(message.current_interface));\n            dispatch(updateMitigations(message.active_mitigations));\n            break;\n            \n          case 'packet':\n            dispatch(addPacket(message.packet));\n            break;\n            \n          case 'attack_detected':\n            dispatch(addDetectedAttack(message.attack));\n            break;\n            \n          case 'mitigation_update':\n            dispatch(updateMitigations(message.active_mitigations));\n            break;\n            \n          default:\n            console.warn('Unknown message type:', message.type);\n        }\n      };\n      \n      // Add message handler\n      webSocketService.onMessage(messageHandler);\n      \n      // Return cleanup function\n      return () => {\n        webSocketService.removeMessageHandler(messageHandler);\n      };\n    } catch (error) {\n      console.error('Failed to connect to backend:', error);\n      throw error;\n    }\n  }\n);\n\nexport const startCapture = createAsyncThunk(\n  'network/startCapture',\n  async (interfaceName, { getState }) => {\n    await webSocketService.sendMessage({\n      type: 'start_capture',\n      interface: interfaceName\n    });\n    return { interface: interfaceName };\n  }\n);\n\nexport const stopCapture = createAsyncThunk(\n  'network/stopCapture',\n  async () => {\n    await webSocketService.sendMessage({\n      type: 'stop_capture'\n    });\n    return { isCapturing: false };\n  }\n);\n\nexport const applyMitigation = createAsyncThunk(\n  'network/applyMitigation',\n  async ({ target, action }, { dispatch }) => {\n    await webSocketService.sendMessage({\n      type: 'mitigate',\n      target,\n      action\n    });\n    return { target, action };\n  }\n);\n\nexport const reconnect = createAsyncThunk(\n  'network/reconnect',\n  async () => {\n    await webSocketService.connect('ws://localhost:8080');\n    return { reconnecting: false };\n  }\n);\n\n// Slice\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setInterfaces: (state, action) => {\n      state.interfaces = Array.isArray(action.payload) ? action.payload : [];\n      state.lastUpdated = new Date().toISOString();\n    },\n    setIsCapturing: (state, action) => {\n      state.isCapturing = Boolean(action.payload);\n      state.lastUpdated = new Date().toISOString();\n    },\n    setCurrentInterface: (state, action) => {\n      state.currentInterface = action.payload || null;\n      state.lastUpdated = new Date().toISOString();\n    },\n    addPacket: (state, action) => {\n      const packet = action.payload || {};\n      // Ensure packet has required fields\n      if (packet.timestamp && (packet.src || packet.dst)) {\n        state.packets.unshift({\n          ...packet,\n          protocol: packet.protocol || 'unknown',\n          length: packet.length || 0,\n          info: packet.info || {},\n          timestamp: packet.timestamp || new Date().toISOString()\n        });\n        \n        // Limit packet history\n        if (state.packets.length > 1000) {\n          state.packets.pop();\n        }\n        \n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    updateStats: (state, action) => {\n      if (action.payload) {\n        state.stats = {\n          packetCount: Number(action.payload.packetCount) || state.stats.packetCount,\n          protocols: {\n            tcp: Number(action.payload.protocols?.tcp) || state.stats.protocols.tcp,\n            udp: Number(action.payload.protocols?.udp) || state.stats.protocols.udp,\n            icmp: Number(action.payload.protocols?.icmp) || state.stats.protocols.icmp,\n            other: Number(action.payload.protocols?.other) || state.stats.protocols.other\n          },\n          sourceIps: action.payload.sourceIps || state.stats.sourceIps,\n          destinationIps: action.payload.destinationIps || state.stats.destinationIps\n        };\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    setBandwidth: (state, action) => {\n      if (action.payload) {\n        state.bandwidth = {\n          bpsReceived: Number(action.payload.bpsReceived) || 0,\n          bpsSent: Number(action.payload.bpsSent) || 0,\n          totalReceived: Number(action.payload.totalReceived) || 0,\n          totalSent: Number(action.payload.totalSent) || 0,\n          lastUpdated: new Date().toISOString()\n        };\n      }\n    },\n    addDetectedAttack: (state, action) => {\n      if (action.payload) {\n        state.detectedAttacks.unshift({\n          ...action.payload,\n          timestamp: action.payload.timestamp || new Date().toISOString()\n        });\n        \n        // Limit attack history\n        if (state.detectedAttacks.length > 100) {\n          state.detectedAttacks.pop();\n        }\n        \n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    updateMitigations: (state, action) => {\n      if (action.payload && typeof action.payload === 'object') {\n        state.activeMitigations = {\n          ...state.activeMitigations,\n          ...action.payload\n        };\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    setError: (state, action) => {\n      state.error = action.payload;\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(connectToBackend.fulfilled, (state) => {\n        state.isConnected = true;\n        state.error = null;\n      })\n      .addCase(connectToBackend.rejected, (state, action) => {\n        state.isConnected = false;\n        state.error = action.error.message;\n      })\n      .addCase(startCapture.fulfilled, (state, action) => {\n        state.isCapturing = true;\n        state.currentInterface = action.payload.interface;\n      })\n      .addCase(stopCapture.fulfilled, (state) => {\n        state.isCapturing = false;\n      })\n      .addCase(applyMitigation.fulfilled, (state, action) => {\n        const { target, action: mitigationAction } = action.payload;\n        state.activeMitigations[target] = {\n          action: mitigationAction,\n          timestamp: new Date().toISOString(),\n          expires: new Date(Date.now() + 3600000).toISOString() // 1 hour from now\n        };\n      });\n  }\n});\n\n// Export actions\nexport const {\n  setInterfaces,\n  setIsCapturing,\n  setCurrentInterface,\n  addPacket,\n  updateStats,\n  setBandwidth,\n  addDetectedAttack,\n  updateMitigations,\n  setError\n} = networkSlice.actions;\n\n// Export selectors\nexport const selectIsConnected = (state) => state.network.isConnected;\nexport const selectIsCapturing = (state) => state.network.isCapturing;\nexport const selectInterfaces = (state) => state.network.interfaces;\nexport const selectCurrentInterface = (state) => state.network.currentInterface;\nexport const selectPackets = (state) => state.network.packets;\nexport const selectStats = (state) => state.network.stats;\nexport const selectBandwidth = (state) => state.network.bandwidth;\nexport const selectDetectedAttacks = (state) => state.network.detectedAttacks;\nexport const selectActiveMitigations = (state) => state.network.activeMitigations;\nexport const selectError = (state) => state.network.error;\n\nexport default networkSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}