{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { webSocketService } from '../../services/websocketService';\n\n// WebSocket server URL (should be moved to environment variables in production)\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8080/ws';\nconst PACKET_CAPTURE_WS_URL = process.env.REACT_APP_PACKET_CAPTURE_WS_URL || 'ws://localhost:8080/ws/packets';\nconst initialState = {\n  status: 'disconnected',\n  // 'disconnected', 'connecting', 'connected', 'error'\n  error: null,\n  interfaces: [],\n  availableInterfaces: ['Wi-Fi', 'Ethernet'],\n  activeInterface: 'Wi-Fi',\n  isCapturing: false,\n  isCaptureConnected: false,\n  packets: [],\n  stats: {\n    total: 0,\n    tcp: 0,\n    udp: 0,\n    http: 0,\n    https: 0,\n    dns: 0,\n    other: 0,\n    dropped: 0\n  },\n  bandwidth: {\n    in: 0,\n    out: 0,\n    history: [],\n    lastUpdate: null\n  },\n  filters: {\n    protocol: 'all',\n    sourceIp: '',\n    destinationIp: '',\n    port: ''\n  },\n  selectedPacket: null\n};\n\n// Thunks for WebSocket operations\nexport const connectToCapture = createAsyncThunk('network/connectToCapture', async (_, {\n  dispatch,\n  getState\n}) => {\n  try {\n    const {\n      activeInterface\n    } = getState().network;\n    if (!activeInterface) {\n      throw new Error('No network interface selected');\n    }\n\n    // Connect to WebSocket server\n    await webSocketService.connect(WS_URL);\n\n    // Set up packet capture WebSocket\n    const packetWs = new WebSocket(PACKET_CAPTURE_WS_URL);\n    packetWs.onopen = () => {\n      dispatch(setCaptureConnected(true));\n    };\n    packetWs.onmessage = event => {\n      const message = JSON.parse(event.data);\n      if (message.type === 'packet') {\n        dispatch(addPacket(message.data));\n      } else if (message.type === 'status') {\n        dispatch(updateCaptureStatus(message.data));\n      }\n    };\n    packetWs.onclose = () => {\n      dispatch(setCaptureConnected(false));\n    };\n\n    // Store WebSocket instance in the state for later use\n    return {\n      ws: packetWs\n    };\n\n    // Set up message handler\n    webSocketService.addMessageHandler(message => {\n      switch (message.type) {\n        case 'packet':\n          dispatch(addPacket(message.payload));\n          break;\n        case 'stats/update':\n          dispatch(updateStats(message.payload));\n          break;\n        case 'bandwidth/update':\n          dispatch(updateBandwidth(message.payload));\n          break;\n        case 'interfaces/update':\n          dispatch(updateInterfaces(message.payload));\n          break;\n        case 'error':\n          console.error('WebSocket Error:', message.payload);\n          break;\n        default:\n          console.log('Unhandled message type:', message.type);\n      }\n    });\n\n    // Request initial data\n    webSocketService.sendMessage({\n      type: 'interfaces/list'\n    });\n    return {\n      status: 'connected'\n    };\n  } catch (error) {\n    console.error('WebSocket connection failed:', error);\n    return {\n      error: error.message\n    };\n  }\n});\nexport const startCapture = createAsyncThunk('network/startCapture', async (_, {\n  getState\n}) => {\n  const {\n    activeInterface\n  } = getState().network;\n  if (!activeInterface) {\n    throw new Error('No network interface selected');\n  }\n  const success = webSocketService.startCapture(activeInterface);\n  if (!success) {\n    throw new Error('Failed to send start capture command');\n  }\n  return {\n    success: true\n  };\n});\nexport const stopCapture = createAsyncThunk('network/stopCapture', async () => {\n  const success = webSocketService.stopCapture();\n  if (!success) {\n    throw new Error('Failed to send stop capture command');\n  }\n  return {\n    success: true\n  };\n});\nexport const updateCaptureFilter = createAsyncThunk('network/updateCaptureFilter', async (filter, {\n  getState\n}) => {\n  const success = webSocketService.setFilter(filter);\n  if (!success) {\n    throw new Error('Failed to update capture filter');\n  }\n  return {\n    filter\n  };\n});\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setActiveInterface(state, action) {\n      state.activeInterface = action.payload;\n    },\n    setCaptureConnected(state, action) {\n      state.isCaptureConnected = action.payload;\n    },\n    updateCaptureStatus(state, action) {\n      if (action.payload) {\n        var _action$payload$isCap, _action$payload$inter;\n        state.isCapturing = (_action$payload$isCap = action.payload.isCapturing) !== null && _action$payload$isCap !== void 0 ? _action$payload$isCap : state.isCapturing;\n        state.activeInterface = (_action$payload$inter = action.payload.interface) !== null && _action$payload$inter !== void 0 ? _action$payload$inter : state.activeInterface;\n        if (action.payload.status) {\n          state.status = action.payload.status;\n        }\n      }\n    },\n    addPacket(state, action) {\n      var _packet$protocol;\n      const packet = action.payload;\n      state.packets.unshift(packet);\n      state.stats.total += 1;\n      // Update protocol stats\n      const protocol = ((_packet$protocol = packet.protocol) === null || _packet$protocol === void 0 ? void 0 : _packet$protocol.toLowerCase()) || 'other';\n      if (state.stats[protocol] !== undefined) {\n        state.stats[protocol] += 1;\n      } else {\n        state.stats.other += 1;\n      }\n\n      // Update bandwidth\n      const now = Date.now();\n      const length = packet.length || 0;\n      state.bandwidth.in += length;\n\n      // Keep last 100 bandwidth updates\n      state.bandwidth.history.push({\n        time: now,\n        value: length\n      });\n      if (state.bandwidth.history.length > 100) {\n        state.bandwidth.history.shift();\n      }\n      state.bandwidth.lastUpdate = now;\n    },\n    updateStats(state, action) {\n      state.stats = {\n        ...state.stats,\n        ...action.payload\n      };\n    },\n    updateBandwidth(state, action) {\n      const {\n        in: inBytes,\n        out: outBytes\n      } = action.payload;\n      const now = new Date().toISOString();\n      state.bandwidth.in = inBytes;\n      state.bandwidth.out = outBytes;\n      state.bandwidth.history.push({\n        timestamp: now,\n        in: inBytes,\n        out: outBytes\n      });\n\n      // Keep only the last 60 data points (1 minute at 1s intervals)\n      if (state.bandwidth.history.length > 60) {\n        state.bandwidth.history.shift();\n      }\n      state.bandwidth.lastUpdate = now;\n    },\n    updateInterfaces(state, action) {\n      state.interfaces = action.payload;\n      if (action.payload.length > 0 && !state.activeInterface) {\n        state.activeInterface = action.payload[0].name;\n      }\n    },\n    setFilter(state, action) {\n      state.filters = {\n        ...state.filters,\n        ...action.payload\n      };\n    },\n    selectPacket(state, action) {\n      state.selectedPacket = action.payload;\n    },\n    clearPackets(state) {\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0\n      };\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(connectToCapture.pending, state => {\n      state.status = 'connecting';\n    }).addCase(connectToCapture.fulfilled, (state, action) => {\n      if (action.payload.error) {\n        state.status = 'error';\n        state.error = action.payload.error;\n      } else {\n        state.status = 'connected';\n      }\n    }).addCase(connectToCapture.rejected, (state, action) => {\n      state.status = 'error';\n      state.error = action.error.message;\n    }).addCase(startCapture.pending, state => {\n      state.isCapturing = true;\n    }).addCase(startCapture.fulfilled, state => {\n      state.isCapturing = true;\n    }).addCase(startCapture.rejected, (state, action) => {\n      state.isCapturing = false;\n      state.error = action.error.message;\n    });\n  }\n});\nexport const {\n  setActiveInterface,\n  setCaptureConnected,\n  updateCaptureStatus,\n  addPacket,\n  updateStats,\n  updateBandwidth,\n  updateInterfaces,\n  setFilter,\n  selectPacket,\n  clearPackets\n} = networkSlice.actions;\nexport default networkSlice.reducer;\n\n// Selectors\nexport const selectNetworkStatus = state => state.network.status;\nexport const selectInterfaces = state => state.network.interfaces;\nexport const selectActiveInterface = state => state.network.activeInterface;\nexport const selectIsCapturing = state => state.network.isCapturing;\nexport const selectPackets = state => state.network.packets;\nexport const selectStats = state => state.network.stats;\nexport const selectBandwidth = state => state.network.bandwidth;\nexport const selectFilters = state => state.network.filters;\nexport const selectSelectedPacket = state => state.network.selectedPacket;\nexport const selectFilteredPackets = state => {\n  const {\n    packets,\n    filters\n  } = state.network;\n  const {\n    protocol,\n    sourceIp,\n    destinationIp,\n    port\n  } = filters;\n\n  // If no filters are active, return all packets\n  const hasActiveFilters = protocol !== 'all' || sourceIp || destinationIp || port;\n  if (!hasActiveFilters) {\n    return packets;\n  }\n  return packets.filter(packet => {\n    // Filter by protocol\n    if (protocol !== 'all' && packet.protocol && !packet.protocol.toLowerCase().includes(protocol.toLowerCase())) {\n      return false;\n    }\n\n    // Filter by source IP\n    if (sourceIp && packet.source && !packet.source.toLowerCase().includes(sourceIp.toLowerCase())) {\n      return false;\n    }\n\n    // Filter by destination IP\n    if (destinationIp && packet.destination && !packet.destination.toLowerCase().includes(destinationIp.toLowerCase())) {\n      return false;\n    }\n\n    // Filter by port (check both source and destination ports if they exist)\n    if (port) {\n      var _packet$source, _packet$destination;\n      const portStr = port.toString();\n      const sourcePort = (_packet$source = packet.source) === null || _packet$source === void 0 ? void 0 : _packet$source.split(':')[1];\n      const destPort = (_packet$destination = packet.destination) === null || _packet$destination === void 0 ? void 0 : _packet$destination.split(':')[1];\n      if ((!sourcePort || sourcePort !== portStr) && (!destPort || destPort !== portStr)) {\n        return false;\n      }\n    }\n    return true;\n  });\n};\n\n// New selector for capture status\nexport const selectCaptureStatus = state => ({\n  isConnected: state.network.isCaptureConnected,\n  isCapturing: state.network.isCapturing,\n  activeInterface: state.network.activeInterface,\n  availableInterfaces: state.network.availableInterfaces\n});\n\n// Async thunks are already exported from createAsyncThunk\n// No need to re-export them here","map":{"version":3,"names":["createSlice","createAsyncThunk","webSocketService","WS_URL","process","env","REACT_APP_WS_URL","PACKET_CAPTURE_WS_URL","REACT_APP_PACKET_CAPTURE_WS_URL","initialState","status","error","interfaces","availableInterfaces","activeInterface","isCapturing","isCaptureConnected","packets","stats","total","tcp","udp","http","https","dns","other","dropped","bandwidth","in","out","history","lastUpdate","filters","protocol","sourceIp","destinationIp","port","selectedPacket","connectToCapture","_","dispatch","getState","network","Error","connect","packetWs","WebSocket","onopen","setCaptureConnected","onmessage","event","message","JSON","parse","data","type","addPacket","updateCaptureStatus","onclose","ws","addMessageHandler","payload","updateStats","updateBandwidth","updateInterfaces","console","log","sendMessage","startCapture","success","stopCapture","updateCaptureFilter","filter","setFilter","networkSlice","name","reducers","setActiveInterface","state","action","_action$payload$isCap","_action$payload$inter","interface","_packet$protocol","packet","unshift","toLowerCase","undefined","now","Date","length","push","time","value","shift","inBytes","outBytes","toISOString","timestamp","selectPacket","clearPackets","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","reducer","selectNetworkStatus","selectInterfaces","selectActiveInterface","selectIsCapturing","selectPackets","selectStats","selectBandwidth","selectFilters","selectSelectedPacket","selectFilteredPackets","hasActiveFilters","includes","source","destination","_packet$source","_packet$destination","portStr","toString","sourcePort","split","destPort","selectCaptureStatus","isConnected"],"sources":["C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/src/features/network/networkSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { webSocketService } from '../../services/websocketService';\n\n// WebSocket server URL (should be moved to environment variables in production)\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8080/ws';\nconst PACKET_CAPTURE_WS_URL = process.env.REACT_APP_PACKET_CAPTURE_WS_URL || 'ws://localhost:8080/ws/packets';\n\nconst initialState = {\n  status: 'disconnected', // 'disconnected', 'connecting', 'connected', 'error'\n  error: null,\n  interfaces: [],\n  availableInterfaces: ['Wi-Fi', 'Ethernet'],\n  activeInterface: 'Wi-Fi',\n  isCapturing: false,\n  isCaptureConnected: false,\n  packets: [],\n  stats: {\n    total: 0,\n    tcp: 0,\n    udp: 0,\n    http: 0,\n    https: 0,\n    dns: 0,\n    other: 0,\n    dropped: 0,\n  },\n  bandwidth: {\n    in: 0,\n    out: 0,\n    history: [],\n    lastUpdate: null,\n  },\n  filters: {\n    protocol: 'all',\n    sourceIp: '',\n    destinationIp: '',\n    port: '',\n  },\n  selectedPacket: null,\n};\n\n// Thunks for WebSocket operations\nexport const connectToCapture = createAsyncThunk(\n  'network/connectToCapture',\n  async (_, { dispatch, getState }) => {\n    try {\n      const { activeInterface } = getState().network;\n      if (!activeInterface) {\n        throw new Error('No network interface selected');\n      }\n\n      // Connect to WebSocket server\n      await webSocketService.connect(WS_URL);\n      \n      // Set up packet capture WebSocket\n      const packetWs = new WebSocket(PACKET_CAPTURE_WS_URL);\n      \n      packetWs.onopen = () => {\n        dispatch(setCaptureConnected(true));\n      };\n      \n      packetWs.onmessage = (event) => {\n        const message = JSON.parse(event.data);\n        if (message.type === 'packet') {\n          dispatch(addPacket(message.data));\n        } else if (message.type === 'status') {\n          dispatch(updateCaptureStatus(message.data));\n        }\n      };\n      \n      packetWs.onclose = () => {\n        dispatch(setCaptureConnected(false));\n      };\n      \n      // Store WebSocket instance in the state for later use\n      return { ws: packetWs };\n      \n      // Set up message handler\n      webSocketService.addMessageHandler((message) => {\n        switch (message.type) {\n          case 'packet':\n            dispatch(addPacket(message.payload));\n            break;\n          case 'stats/update':\n            dispatch(updateStats(message.payload));\n            break;\n          case 'bandwidth/update':\n            dispatch(updateBandwidth(message.payload));\n            break;\n          case 'interfaces/update':\n            dispatch(updateInterfaces(message.payload));\n            break;\n          case 'error':\n            console.error('WebSocket Error:', message.payload);\n            break;\n          default:\n            console.log('Unhandled message type:', message.type);\n        }\n      });\n\n      // Request initial data\n      webSocketService.sendMessage({ type: 'interfaces/list' });\n      \n      return { status: 'connected' };\n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n      return { error: error.message };\n    }\n  }\n);\n\nexport const startCapture = createAsyncThunk(\n  'network/startCapture',\n  async (_, { getState }) => {\n    const { activeInterface } = getState().network;\n    if (!activeInterface) {\n      throw new Error('No network interface selected');\n    }\n    \n    const success = webSocketService.startCapture(activeInterface);\n    if (!success) {\n      throw new Error('Failed to send start capture command');\n    }\n    return { success: true };\n  }\n);\n\nexport const stopCapture = createAsyncThunk(\n  'network/stopCapture',\n  async () => {\n    const success = webSocketService.stopCapture();\n    if (!success) {\n      throw new Error('Failed to send stop capture command');\n    }\n    return { success: true };\n  }\n);\n\nexport const updateCaptureFilter = createAsyncThunk(\n  'network/updateCaptureFilter',\n  async (filter, { getState }) => {\n    const success = webSocketService.setFilter(filter);\n    if (!success) {\n      throw new Error('Failed to update capture filter');\n    }\n    return { filter };\n  }\n);\n\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setActiveInterface(state, action) {\n      state.activeInterface = action.payload;\n    },\n    setCaptureConnected(state, action) {\n      state.isCaptureConnected = action.payload;\n    },\n    updateCaptureStatus(state, action) {\n      if (action.payload) {\n        state.isCapturing = action.payload.isCapturing ?? state.isCapturing;\n        state.activeInterface = action.payload.interface ?? state.activeInterface;\n        if (action.payload.status) {\n          state.status = action.payload.status;\n        }\n      }\n    },\n    addPacket(state, action) {\n      const packet = action.payload;\n      state.packets.unshift(packet);\n      state.stats.total += 1;\n      // Update protocol stats\n      const protocol = packet.protocol?.toLowerCase() || 'other';\n      if (state.stats[protocol] !== undefined) {\n        state.stats[protocol] += 1;\n      } else {\n        state.stats.other += 1;\n      }\n      \n      // Update bandwidth\n      const now = Date.now();\n      const length = packet.length || 0;\n      state.bandwidth.in += length;\n      \n      // Keep last 100 bandwidth updates\n      state.bandwidth.history.push({ time: now, value: length });\n      if (state.bandwidth.history.length > 100) {\n        state.bandwidth.history.shift();\n      }\n      state.bandwidth.lastUpdate = now;\n    },\n    updateStats(state, action) {\n      state.stats = { ...state.stats, ...action.payload };\n    },\n    updateBandwidth(state, action) {\n      const { in: inBytes, out: outBytes } = action.payload;\n      const now = new Date().toISOString();\n      \n      state.bandwidth.in = inBytes;\n      state.bandwidth.out = outBytes;\n      state.bandwidth.history.push({\n        timestamp: now,\n        in: inBytes,\n        out: outBytes\n      });\n      \n      // Keep only the last 60 data points (1 minute at 1s intervals)\n      if (state.bandwidth.history.length > 60) {\n        state.bandwidth.history.shift();\n      }\n      \n      state.bandwidth.lastUpdate = now;\n    },\n    updateInterfaces(state, action) {\n      state.interfaces = action.payload;\n      if (action.payload.length > 0 && !state.activeInterface) {\n        state.activeInterface = action.payload[0].name;\n      }\n    },\n    setFilter(state, action) {\n      state.filters = { ...state.filters, ...action.payload };\n    },\n    selectPacket(state, action) {\n      state.selectedPacket = action.payload;\n    },\n    clearPackets(state) {\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0,\n      };\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(connectToCapture.pending, (state) => {\n        state.status = 'connecting';\n      })\n      .addCase(connectToCapture.fulfilled, (state, action) => {\n        if (action.payload.error) {\n          state.status = 'error';\n          state.error = action.payload.error;\n        } else {\n          state.status = 'connected';\n        }\n      })\n      .addCase(connectToCapture.rejected, (state, action) => {\n        state.status = 'error';\n        state.error = action.error.message;\n      })\n      .addCase(startCapture.pending, (state) => {\n        state.isCapturing = true;\n      })\n      .addCase(startCapture.fulfilled, (state) => {\n        state.isCapturing = true;\n      })\n      .addCase(startCapture.rejected, (state, action) => {\n        state.isCapturing = false;\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport const { \n  setActiveInterface, \n  setCaptureConnected, \n  updateCaptureStatus,\n  addPacket, \n  updateStats, \n  updateBandwidth, \n  updateInterfaces, \n  setFilter, \n  selectPacket, \n  clearPackets \n} = networkSlice.actions;\n\nexport default networkSlice.reducer;\n\n// Selectors\nexport const selectNetworkStatus = (state) => state.network.status;\nexport const selectInterfaces = (state) => state.network.interfaces;\nexport const selectActiveInterface = (state) => state.network.activeInterface;\nexport const selectIsCapturing = (state) => state.network.isCapturing;\nexport const selectPackets = (state) => state.network.packets;\nexport const selectStats = (state) => state.network.stats;\nexport const selectBandwidth = (state) => state.network.bandwidth;\nexport const selectFilters = (state) => state.network.filters;\nexport const selectSelectedPacket = (state) => state.network.selectedPacket;\n\nexport const selectFilteredPackets = (state) => {\n  const { packets, filters } = state.network;\n  const { protocol, sourceIp, destinationIp, port } = filters;\n\n  // If no filters are active, return all packets\n  const hasActiveFilters = protocol !== 'all' || sourceIp || destinationIp || port;\n  if (!hasActiveFilters) {\n    return packets;\n  }\n\n  return packets.filter((packet) => {\n    // Filter by protocol\n    if (protocol !== 'all' && packet.protocol && \n        !packet.protocol.toLowerCase().includes(protocol.toLowerCase())) {\n      return false;\n    }\n\n    // Filter by source IP\n    if (sourceIp && packet.source && \n        !packet.source.toLowerCase().includes(sourceIp.toLowerCase())) {\n      return false;\n    }\n\n    // Filter by destination IP\n    if (destinationIp && packet.destination && \n        !packet.destination.toLowerCase().includes(destinationIp.toLowerCase())) {\n      return false;\n    }\n\n    // Filter by port (check both source and destination ports if they exist)\n    if (port) {\n      const portStr = port.toString();\n      const sourcePort = packet.source?.split(':')[1];\n      const destPort = packet.destination?.split(':')[1];\n      \n      if ((!sourcePort || sourcePort !== portStr) && \n          (!destPort || destPort !== portStr)) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n};\n\n// New selector for capture status\nexport const selectCaptureStatus = (state) => ({\n  isConnected: state.network.isCaptureConnected,\n  isCapturing: state.network.isCapturing,\n  activeInterface: state.network.activeInterface,\n  availableInterfaces: state.network.availableInterfaces\n});\n\n// Async thunks are already exported from createAsyncThunk\n// No need to re-export them here\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,gBAAgB,QAAQ,kBAAkB;AAChE,SAASC,gBAAgB,QAAQ,iCAAiC;;AAElE;AACA,MAAMC,MAAM,GAAGC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAAI,wBAAwB;AACvE,MAAMC,qBAAqB,GAAGH,OAAO,CAACC,GAAG,CAACG,+BAA+B,IAAI,gCAAgC;AAE7G,MAAMC,YAAY,GAAG;EACnBC,MAAM,EAAE,cAAc;EAAE;EACxBC,KAAK,EAAE,IAAI;EACXC,UAAU,EAAE,EAAE;EACdC,mBAAmB,EAAE,CAAC,OAAO,EAAE,UAAU,CAAC;EAC1CC,eAAe,EAAE,OAAO;EACxBC,WAAW,EAAE,KAAK;EAClBC,kBAAkB,EAAE,KAAK;EACzBC,OAAO,EAAE,EAAE;EACXC,KAAK,EAAE;IACLC,KAAK,EAAE,CAAC;IACRC,GAAG,EAAE,CAAC;IACNC,GAAG,EAAE,CAAC;IACNC,IAAI,EAAE,CAAC;IACPC,KAAK,EAAE,CAAC;IACRC,GAAG,EAAE,CAAC;IACNC,KAAK,EAAE,CAAC;IACRC,OAAO,EAAE;EACX,CAAC;EACDC,SAAS,EAAE;IACTC,EAAE,EAAE,CAAC;IACLC,GAAG,EAAE,CAAC;IACNC,OAAO,EAAE,EAAE;IACXC,UAAU,EAAE;EACd,CAAC;EACDC,OAAO,EAAE;IACPC,QAAQ,EAAE,KAAK;IACfC,QAAQ,EAAE,EAAE;IACZC,aAAa,EAAE,EAAE;IACjBC,IAAI,EAAE;EACR,CAAC;EACDC,cAAc,EAAE;AAClB,CAAC;;AAED;AACA,OAAO,MAAMC,gBAAgB,GAAGrC,gBAAgB,CAC9C,0BAA0B,EAC1B,OAAOsC,CAAC,EAAE;EAAEC,QAAQ;EAAEC;AAAS,CAAC,KAAK;EACnC,IAAI;IACF,MAAM;MAAE3B;IAAgB,CAAC,GAAG2B,QAAQ,CAAC,CAAC,CAACC,OAAO;IAC9C,IAAI,CAAC5B,eAAe,EAAE;MACpB,MAAM,IAAI6B,KAAK,CAAC,+BAA+B,CAAC;IAClD;;IAEA;IACA,MAAMzC,gBAAgB,CAAC0C,OAAO,CAACzC,MAAM,CAAC;;IAEtC;IACA,MAAM0C,QAAQ,GAAG,IAAIC,SAAS,CAACvC,qBAAqB,CAAC;IAErDsC,QAAQ,CAACE,MAAM,GAAG,MAAM;MACtBP,QAAQ,CAACQ,mBAAmB,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC;IAEDH,QAAQ,CAACI,SAAS,GAAIC,KAAK,IAAK;MAC9B,MAAMC,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,CAACI,IAAI,CAAC;MACtC,IAAIH,OAAO,CAACI,IAAI,KAAK,QAAQ,EAAE;QAC7Bf,QAAQ,CAACgB,SAAS,CAACL,OAAO,CAACG,IAAI,CAAC,CAAC;MACnC,CAAC,MAAM,IAAIH,OAAO,CAACI,IAAI,KAAK,QAAQ,EAAE;QACpCf,QAAQ,CAACiB,mBAAmB,CAACN,OAAO,CAACG,IAAI,CAAC,CAAC;MAC7C;IACF,CAAC;IAEDT,QAAQ,CAACa,OAAO,GAAG,MAAM;MACvBlB,QAAQ,CAACQ,mBAAmB,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;;IAED;IACA,OAAO;MAAEW,EAAE,EAAEd;IAAS,CAAC;;IAEvB;IACA3C,gBAAgB,CAAC0D,iBAAiB,CAAET,OAAO,IAAK;MAC9C,QAAQA,OAAO,CAACI,IAAI;QAClB,KAAK,QAAQ;UACXf,QAAQ,CAACgB,SAAS,CAACL,OAAO,CAACU,OAAO,CAAC,CAAC;UACpC;QACF,KAAK,cAAc;UACjBrB,QAAQ,CAACsB,WAAW,CAACX,OAAO,CAACU,OAAO,CAAC,CAAC;UACtC;QACF,KAAK,kBAAkB;UACrBrB,QAAQ,CAACuB,eAAe,CAACZ,OAAO,CAACU,OAAO,CAAC,CAAC;UAC1C;QACF,KAAK,mBAAmB;UACtBrB,QAAQ,CAACwB,gBAAgB,CAACb,OAAO,CAACU,OAAO,CAAC,CAAC;UAC3C;QACF,KAAK,OAAO;UACVI,OAAO,CAACtD,KAAK,CAAC,kBAAkB,EAAEwC,OAAO,CAACU,OAAO,CAAC;UAClD;QACF;UACEI,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEf,OAAO,CAACI,IAAI,CAAC;MACxD;IACF,CAAC,CAAC;;IAEF;IACArD,gBAAgB,CAACiE,WAAW,CAAC;MAAEZ,IAAI,EAAE;IAAkB,CAAC,CAAC;IAEzD,OAAO;MAAE7C,MAAM,EAAE;IAAY,CAAC;EAChC,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdsD,OAAO,CAACtD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;IACpD,OAAO;MAAEA,KAAK,EAAEA,KAAK,CAACwC;IAAQ,CAAC;EACjC;AACF,CACF,CAAC;AAED,OAAO,MAAMiB,YAAY,GAAGnE,gBAAgB,CAC1C,sBAAsB,EACtB,OAAOsC,CAAC,EAAE;EAAEE;AAAS,CAAC,KAAK;EACzB,MAAM;IAAE3B;EAAgB,CAAC,GAAG2B,QAAQ,CAAC,CAAC,CAACC,OAAO;EAC9C,IAAI,CAAC5B,eAAe,EAAE;IACpB,MAAM,IAAI6B,KAAK,CAAC,+BAA+B,CAAC;EAClD;EAEA,MAAM0B,OAAO,GAAGnE,gBAAgB,CAACkE,YAAY,CAACtD,eAAe,CAAC;EAC9D,IAAI,CAACuD,OAAO,EAAE;IACZ,MAAM,IAAI1B,KAAK,CAAC,sCAAsC,CAAC;EACzD;EACA,OAAO;IAAE0B,OAAO,EAAE;EAAK,CAAC;AAC1B,CACF,CAAC;AAED,OAAO,MAAMC,WAAW,GAAGrE,gBAAgB,CACzC,qBAAqB,EACrB,YAAY;EACV,MAAMoE,OAAO,GAAGnE,gBAAgB,CAACoE,WAAW,CAAC,CAAC;EAC9C,IAAI,CAACD,OAAO,EAAE;IACZ,MAAM,IAAI1B,KAAK,CAAC,qCAAqC,CAAC;EACxD;EACA,OAAO;IAAE0B,OAAO,EAAE;EAAK,CAAC;AAC1B,CACF,CAAC;AAED,OAAO,MAAME,mBAAmB,GAAGtE,gBAAgB,CACjD,6BAA6B,EAC7B,OAAOuE,MAAM,EAAE;EAAE/B;AAAS,CAAC,KAAK;EAC9B,MAAM4B,OAAO,GAAGnE,gBAAgB,CAACuE,SAAS,CAACD,MAAM,CAAC;EAClD,IAAI,CAACH,OAAO,EAAE;IACZ,MAAM,IAAI1B,KAAK,CAAC,iCAAiC,CAAC;EACpD;EACA,OAAO;IAAE6B;EAAO,CAAC;AACnB,CACF,CAAC;AAED,MAAME,YAAY,GAAG1E,WAAW,CAAC;EAC/B2E,IAAI,EAAE,SAAS;EACflE,YAAY;EACZmE,QAAQ,EAAE;IACRC,kBAAkBA,CAACC,KAAK,EAAEC,MAAM,EAAE;MAChCD,KAAK,CAAChE,eAAe,GAAGiE,MAAM,CAAClB,OAAO;IACxC,CAAC;IACDb,mBAAmBA,CAAC8B,KAAK,EAAEC,MAAM,EAAE;MACjCD,KAAK,CAAC9D,kBAAkB,GAAG+D,MAAM,CAAClB,OAAO;IAC3C,CAAC;IACDJ,mBAAmBA,CAACqB,KAAK,EAAEC,MAAM,EAAE;MACjC,IAAIA,MAAM,CAAClB,OAAO,EAAE;QAAA,IAAAmB,qBAAA,EAAAC,qBAAA;QAClBH,KAAK,CAAC/D,WAAW,IAAAiE,qBAAA,GAAGD,MAAM,CAAClB,OAAO,CAAC9C,WAAW,cAAAiE,qBAAA,cAAAA,qBAAA,GAAIF,KAAK,CAAC/D,WAAW;QACnE+D,KAAK,CAAChE,eAAe,IAAAmE,qBAAA,GAAGF,MAAM,CAAClB,OAAO,CAACqB,SAAS,cAAAD,qBAAA,cAAAA,qBAAA,GAAIH,KAAK,CAAChE,eAAe;QACzE,IAAIiE,MAAM,CAAClB,OAAO,CAACnD,MAAM,EAAE;UACzBoE,KAAK,CAACpE,MAAM,GAAGqE,MAAM,CAAClB,OAAO,CAACnD,MAAM;QACtC;MACF;IACF,CAAC;IACD8C,SAASA,CAACsB,KAAK,EAAEC,MAAM,EAAE;MAAA,IAAAI,gBAAA;MACvB,MAAMC,MAAM,GAAGL,MAAM,CAAClB,OAAO;MAC7BiB,KAAK,CAAC7D,OAAO,CAACoE,OAAO,CAACD,MAAM,CAAC;MAC7BN,KAAK,CAAC5D,KAAK,CAACC,KAAK,IAAI,CAAC;MACtB;MACA,MAAMc,QAAQ,GAAG,EAAAkD,gBAAA,GAAAC,MAAM,CAACnD,QAAQ,cAAAkD,gBAAA,uBAAfA,gBAAA,CAAiBG,WAAW,CAAC,CAAC,KAAI,OAAO;MAC1D,IAAIR,KAAK,CAAC5D,KAAK,CAACe,QAAQ,CAAC,KAAKsD,SAAS,EAAE;QACvCT,KAAK,CAAC5D,KAAK,CAACe,QAAQ,CAAC,IAAI,CAAC;MAC5B,CAAC,MAAM;QACL6C,KAAK,CAAC5D,KAAK,CAACO,KAAK,IAAI,CAAC;MACxB;;MAEA;MACA,MAAM+D,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC;MACtB,MAAME,MAAM,GAAGN,MAAM,CAACM,MAAM,IAAI,CAAC;MACjCZ,KAAK,CAACnD,SAAS,CAACC,EAAE,IAAI8D,MAAM;;MAE5B;MACAZ,KAAK,CAACnD,SAAS,CAACG,OAAO,CAAC6D,IAAI,CAAC;QAAEC,IAAI,EAAEJ,GAAG;QAAEK,KAAK,EAAEH;MAAO,CAAC,CAAC;MAC1D,IAAIZ,KAAK,CAACnD,SAAS,CAACG,OAAO,CAAC4D,MAAM,GAAG,GAAG,EAAE;QACxCZ,KAAK,CAACnD,SAAS,CAACG,OAAO,CAACgE,KAAK,CAAC,CAAC;MACjC;MACAhB,KAAK,CAACnD,SAAS,CAACI,UAAU,GAAGyD,GAAG;IAClC,CAAC;IACD1B,WAAWA,CAACgB,KAAK,EAAEC,MAAM,EAAE;MACzBD,KAAK,CAAC5D,KAAK,GAAG;QAAE,GAAG4D,KAAK,CAAC5D,KAAK;QAAE,GAAG6D,MAAM,CAAClB;MAAQ,CAAC;IACrD,CAAC;IACDE,eAAeA,CAACe,KAAK,EAAEC,MAAM,EAAE;MAC7B,MAAM;QAAEnD,EAAE,EAAEmE,OAAO;QAAElE,GAAG,EAAEmE;MAAS,CAAC,GAAGjB,MAAM,CAAClB,OAAO;MACrD,MAAM2B,GAAG,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACQ,WAAW,CAAC,CAAC;MAEpCnB,KAAK,CAACnD,SAAS,CAACC,EAAE,GAAGmE,OAAO;MAC5BjB,KAAK,CAACnD,SAAS,CAACE,GAAG,GAAGmE,QAAQ;MAC9BlB,KAAK,CAACnD,SAAS,CAACG,OAAO,CAAC6D,IAAI,CAAC;QAC3BO,SAAS,EAAEV,GAAG;QACd5D,EAAE,EAAEmE,OAAO;QACXlE,GAAG,EAAEmE;MACP,CAAC,CAAC;;MAEF;MACA,IAAIlB,KAAK,CAACnD,SAAS,CAACG,OAAO,CAAC4D,MAAM,GAAG,EAAE,EAAE;QACvCZ,KAAK,CAACnD,SAAS,CAACG,OAAO,CAACgE,KAAK,CAAC,CAAC;MACjC;MAEAhB,KAAK,CAACnD,SAAS,CAACI,UAAU,GAAGyD,GAAG;IAClC,CAAC;IACDxB,gBAAgBA,CAACc,KAAK,EAAEC,MAAM,EAAE;MAC9BD,KAAK,CAAClE,UAAU,GAAGmE,MAAM,CAAClB,OAAO;MACjC,IAAIkB,MAAM,CAAClB,OAAO,CAAC6B,MAAM,GAAG,CAAC,IAAI,CAACZ,KAAK,CAAChE,eAAe,EAAE;QACvDgE,KAAK,CAAChE,eAAe,GAAGiE,MAAM,CAAClB,OAAO,CAAC,CAAC,CAAC,CAACc,IAAI;MAChD;IACF,CAAC;IACDF,SAASA,CAACK,KAAK,EAAEC,MAAM,EAAE;MACvBD,KAAK,CAAC9C,OAAO,GAAG;QAAE,GAAG8C,KAAK,CAAC9C,OAAO;QAAE,GAAG+C,MAAM,CAAClB;MAAQ,CAAC;IACzD,CAAC;IACDsC,YAAYA,CAACrB,KAAK,EAAEC,MAAM,EAAE;MAC1BD,KAAK,CAACzC,cAAc,GAAG0C,MAAM,CAAClB,OAAO;IACvC,CAAC;IACDuC,YAAYA,CAACtB,KAAK,EAAE;MAClBA,KAAK,CAAC7D,OAAO,GAAG,EAAE;MAClB6D,KAAK,CAAC5D,KAAK,GAAG;QACZC,KAAK,EAAE,CAAC;QACRC,GAAG,EAAE,CAAC;QACNC,GAAG,EAAE,CAAC;QACNC,IAAI,EAAE,CAAC;QACPC,KAAK,EAAE,CAAC;QACRC,GAAG,EAAE,CAAC;QACNC,KAAK,EAAE,CAAC;QACRC,OAAO,EAAE;MACX,CAAC;IACH;EACF,CAAC;EACD2E,aAAa,EAAGC,OAAO,IAAK;IAC1BA,OAAO,CACJC,OAAO,CAACjE,gBAAgB,CAACkE,OAAO,EAAG1B,KAAK,IAAK;MAC5CA,KAAK,CAACpE,MAAM,GAAG,YAAY;IAC7B,CAAC,CAAC,CACD6F,OAAO,CAACjE,gBAAgB,CAACmE,SAAS,EAAE,CAAC3B,KAAK,EAAEC,MAAM,KAAK;MACtD,IAAIA,MAAM,CAAClB,OAAO,CAAClD,KAAK,EAAE;QACxBmE,KAAK,CAACpE,MAAM,GAAG,OAAO;QACtBoE,KAAK,CAACnE,KAAK,GAAGoE,MAAM,CAAClB,OAAO,CAAClD,KAAK;MACpC,CAAC,MAAM;QACLmE,KAAK,CAACpE,MAAM,GAAG,WAAW;MAC5B;IACF,CAAC,CAAC,CACD6F,OAAO,CAACjE,gBAAgB,CAACoE,QAAQ,EAAE,CAAC5B,KAAK,EAAEC,MAAM,KAAK;MACrDD,KAAK,CAACpE,MAAM,GAAG,OAAO;MACtBoE,KAAK,CAACnE,KAAK,GAAGoE,MAAM,CAACpE,KAAK,CAACwC,OAAO;IACpC,CAAC,CAAC,CACDoD,OAAO,CAACnC,YAAY,CAACoC,OAAO,EAAG1B,KAAK,IAAK;MACxCA,KAAK,CAAC/D,WAAW,GAAG,IAAI;IAC1B,CAAC,CAAC,CACDwF,OAAO,CAACnC,YAAY,CAACqC,SAAS,EAAG3B,KAAK,IAAK;MAC1CA,KAAK,CAAC/D,WAAW,GAAG,IAAI;IAC1B,CAAC,CAAC,CACDwF,OAAO,CAACnC,YAAY,CAACsC,QAAQ,EAAE,CAAC5B,KAAK,EAAEC,MAAM,KAAK;MACjDD,KAAK,CAAC/D,WAAW,GAAG,KAAK;MACzB+D,KAAK,CAACnE,KAAK,GAAGoE,MAAM,CAACpE,KAAK,CAACwC,OAAO;IACpC,CAAC,CAAC;EACN;AACF,CAAC,CAAC;AAEF,OAAO,MAAM;EACX0B,kBAAkB;EAClB7B,mBAAmB;EACnBS,mBAAmB;EACnBD,SAAS;EACTM,WAAW;EACXC,eAAe;EACfC,gBAAgB;EAChBS,SAAS;EACT0B,YAAY;EACZC;AACF,CAAC,GAAG1B,YAAY,CAACiC,OAAO;AAExB,eAAejC,YAAY,CAACkC,OAAO;;AAEnC;AACA,OAAO,MAAMC,mBAAmB,GAAI/B,KAAK,IAAKA,KAAK,CAACpC,OAAO,CAAChC,MAAM;AAClE,OAAO,MAAMoG,gBAAgB,GAAIhC,KAAK,IAAKA,KAAK,CAACpC,OAAO,CAAC9B,UAAU;AACnE,OAAO,MAAMmG,qBAAqB,GAAIjC,KAAK,IAAKA,KAAK,CAACpC,OAAO,CAAC5B,eAAe;AAC7E,OAAO,MAAMkG,iBAAiB,GAAIlC,KAAK,IAAKA,KAAK,CAACpC,OAAO,CAAC3B,WAAW;AACrE,OAAO,MAAMkG,aAAa,GAAInC,KAAK,IAAKA,KAAK,CAACpC,OAAO,CAACzB,OAAO;AAC7D,OAAO,MAAMiG,WAAW,GAAIpC,KAAK,IAAKA,KAAK,CAACpC,OAAO,CAACxB,KAAK;AACzD,OAAO,MAAMiG,eAAe,GAAIrC,KAAK,IAAKA,KAAK,CAACpC,OAAO,CAACf,SAAS;AACjE,OAAO,MAAMyF,aAAa,GAAItC,KAAK,IAAKA,KAAK,CAACpC,OAAO,CAACV,OAAO;AAC7D,OAAO,MAAMqF,oBAAoB,GAAIvC,KAAK,IAAKA,KAAK,CAACpC,OAAO,CAACL,cAAc;AAE3E,OAAO,MAAMiF,qBAAqB,GAAIxC,KAAK,IAAK;EAC9C,MAAM;IAAE7D,OAAO;IAAEe;EAAQ,CAAC,GAAG8C,KAAK,CAACpC,OAAO;EAC1C,MAAM;IAAET,QAAQ;IAAEC,QAAQ;IAAEC,aAAa;IAAEC;EAAK,CAAC,GAAGJ,OAAO;;EAE3D;EACA,MAAMuF,gBAAgB,GAAGtF,QAAQ,KAAK,KAAK,IAAIC,QAAQ,IAAIC,aAAa,IAAIC,IAAI;EAChF,IAAI,CAACmF,gBAAgB,EAAE;IACrB,OAAOtG,OAAO;EAChB;EAEA,OAAOA,OAAO,CAACuD,MAAM,CAAEY,MAAM,IAAK;IAChC;IACA,IAAInD,QAAQ,KAAK,KAAK,IAAImD,MAAM,CAACnD,QAAQ,IACrC,CAACmD,MAAM,CAACnD,QAAQ,CAACqD,WAAW,CAAC,CAAC,CAACkC,QAAQ,CAACvF,QAAQ,CAACqD,WAAW,CAAC,CAAC,CAAC,EAAE;MACnE,OAAO,KAAK;IACd;;IAEA;IACA,IAAIpD,QAAQ,IAAIkD,MAAM,CAACqC,MAAM,IACzB,CAACrC,MAAM,CAACqC,MAAM,CAACnC,WAAW,CAAC,CAAC,CAACkC,QAAQ,CAACtF,QAAQ,CAACoD,WAAW,CAAC,CAAC,CAAC,EAAE;MACjE,OAAO,KAAK;IACd;;IAEA;IACA,IAAInD,aAAa,IAAIiD,MAAM,CAACsC,WAAW,IACnC,CAACtC,MAAM,CAACsC,WAAW,CAACpC,WAAW,CAAC,CAAC,CAACkC,QAAQ,CAACrF,aAAa,CAACmD,WAAW,CAAC,CAAC,CAAC,EAAE;MAC3E,OAAO,KAAK;IACd;;IAEA;IACA,IAAIlD,IAAI,EAAE;MAAA,IAAAuF,cAAA,EAAAC,mBAAA;MACR,MAAMC,OAAO,GAAGzF,IAAI,CAAC0F,QAAQ,CAAC,CAAC;MAC/B,MAAMC,UAAU,IAAAJ,cAAA,GAAGvC,MAAM,CAACqC,MAAM,cAAAE,cAAA,uBAAbA,cAAA,CAAeK,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MAC/C,MAAMC,QAAQ,IAAAL,mBAAA,GAAGxC,MAAM,CAACsC,WAAW,cAAAE,mBAAA,uBAAlBA,mBAAA,CAAoBI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MAElD,IAAI,CAAC,CAACD,UAAU,IAAIA,UAAU,KAAKF,OAAO,MACrC,CAACI,QAAQ,IAAIA,QAAQ,KAAKJ,OAAO,CAAC,EAAE;QACvC,OAAO,KAAK;MACd;IACF;IAEA,OAAO,IAAI;EACb,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,OAAO,MAAMK,mBAAmB,GAAIpD,KAAK,KAAM;EAC7CqD,WAAW,EAAErD,KAAK,CAACpC,OAAO,CAAC1B,kBAAkB;EAC7CD,WAAW,EAAE+D,KAAK,CAACpC,OAAO,CAAC3B,WAAW;EACtCD,eAAe,EAAEgE,KAAK,CAACpC,OAAO,CAAC5B,eAAe;EAC9CD,mBAAmB,EAAEiE,KAAK,CAACpC,OAAO,CAAC7B;AACrC,CAAC,CAAC;;AAEF;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}