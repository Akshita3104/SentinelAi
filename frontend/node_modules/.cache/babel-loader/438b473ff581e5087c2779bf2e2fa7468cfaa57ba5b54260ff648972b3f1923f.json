{"ast":null,"code":"var _s = $RefreshSig$();\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = new Set();\n    this.errorHandlers = new Set();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000; // Start with 1 second\n    this.maxReconnectDelay = 10000; // Max 10 seconds\n    this.connectionStatus = 'disconnected';\n    this.connectionStatusListeners = new Set();\n    this.reconnectTimeout = null;\n    this.url = null;\n  }\n  connect(url) {\n    this.url = url;\n    console.log(`[WebSocket] Initializing connection to ${url}`);\n    return new Promise((resolve, reject) => {\n      try {\n        // Close existing connection if any\n        if (this.socket) {\n          console.log('[WebSocket] Closing existing connection...');\n          this.disconnect();\n        }\n        console.log(`[WebSocket] Creating new WebSocket instance to ${url}`);\n        this.socket = new WebSocket(url);\n        this.updateConnectionStatus('connecting');\n\n        // Bind event handlers\n        this.socket.onopen = event => {\n          console.log('[WebSocket] Connection established', {\n            url: this.socket.url,\n            readyState: this.socket.readyState,\n            extensions: this.socket.extensions,\n            protocol: this.socket.protocol\n          });\n          this.reconnectAttempts = 0;\n          this.reconnectDelay = 1000;\n          this.updateConnectionStatus('connected');\n          resolve();\n        };\n        this.socket.onerror = error => {\n          var _this$socket, _this$socket2;\n          const errorMessage = `[WebSocket] Connection error: ${error.message || 'Unknown error'}`;\n          console.error(errorMessage, {\n            readyState: (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState,\n            url: (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.url,\n            error\n          });\n          this.notifyErrorHandlers(error);\n          this.updateConnectionStatus('error');\n\n          // Only reject if this is the initial connection attempt\n          if (this.reconnectAttempts === 0) {\n            const wsError = new Error(errorMessage);\n            console.error('[WebSocket] Rejecting connection promise', wsError);\n            reject(wsError);\n          }\n        };\n        this.socket.onmessage = event => {\n          try {\n            this.notifyHandlers(event.data);\n          } catch (error) {\n            console.error('Error handling WebSocket message:', error, event.data);\n            this.notifyErrorHandlers(error);\n          }\n        };\n        this.socket.onclose = event => {\n          console.log('WebSocket Disconnected', event);\n          this.updateConnectionStatus('disconnected');\n\n          // Don't attempt to reconnect if the close was intentional\n          if (event.code !== 1000) {\n            this.attemptReconnect();\n          }\n        };\n        this.socket.onerror = error => {\n          console.error('WebSocket Error:', error);\n          this.updateConnectionStatus('error');\n          this.socket.close();\n          reject(error);\n        };\n      } catch (error) {\n        console.error('WebSocket Connection Error:', error);\n        reject(error);\n      }\n    });\n  }\n  updateConnectionStatus(status) {\n    this.connectionStatus = status;\n    this.notifyStatusChange(status);\n  }\n  onStatusChange(callback) {\n    this.connectionStatusListeners.add(callback);\n    return () => this.connectionStatusListeners.delete(callback);\n  }\n  notifyStatusChange(status) {\n    this.connectionStatusListeners.forEach(callback => {\n      try {\n        callback(status);\n      } catch (error) {\n        console.error('Error in status change handler:', error);\n      }\n    });\n  }\n  getStatus() {\n    return this.connectionStatus;\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.messageHandlers.clear();\n  }\n  sendMessage(message) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(message));\n      return true;\n    }\n    console.error('WebSocket is not connected');\n    return false;\n  }\n  removeMessageHandler(handler) {\n    this.messageHandlers.delete(handler);\n  }\n  notifyHandlers(message) {\n    this.messageHandlers.forEach(handler => {\n      try {\n        handler(message);\n      } catch (error) {\n        console.error('Error in message handler:', error);\n        this.notifyErrorHandlers(error);\n      }\n    });\n  }\n  onError(handler) {\n    if (typeof handler === 'function') {\n      this.errorHandlers.add(handler);\n      return () => this.errorHandlers.delete(handler);\n    }\n    return () => {};\n  }\n  removeErrorHandler(handler) {\n    this.errorHandlers.delete(handler);\n  }\n  notifyErrorHandlers(error) {\n    this.errorHandlers.forEach(handler => {\n      try {\n        handler(error);\n      } catch (err) {\n        console.error('Error in error handler:', err);\n      }\n    });\n  }\n\n  // Network capture specific methods\n  startCapture(interfaceName) {\n    return this.sendMessage({\n      type: 'start_capture',\n      interface: interfaceName\n    });\n  }\n  stopCapture() {\n    return this.sendMessage({\n      type: 'stop_capture'\n    });\n  }\n  setFilter(filter) {\n    return this.sendMessage({\n      type: 'set_filter',\n      filter: filter\n    });\n  }\n  getInterfaces() {\n    return this.sendMessage({\n      type: 'get_interfaces'\n    });\n  }\n  getPackets(limit = 100, filters = {}) {\n    return this.sendMessage({\n      type: 'get_packets',\n      limit,\n      filters\n    });\n  }\n  getStats() {\n    return this.sendMessage({\n      type: 'get_stats'\n    });\n  }\n  getBandwidth() {\n    return this.sendMessage({\n      type: 'get_bandwidth'\n    });\n  }\n  attemptReconnect() {\n    this.reconnectAttempts++;\n    this.reconnectDelay = Math.min(this.reconnectDelay * 2, this.maxReconnectDelay);\n    this.reconnectTimeout = setTimeout(() => {\n      this.connect(this.url);\n    }, this.reconnectDelay);\n  }\n}\n\n// Export a singleton instance\nexport const webSocketService = new WebSocketService();\n\n// Helper hook for React components\nexport const useWebSocket = (onMessage, dependencies = []) => {\n  _s();\n  const [isConnected, setIsConnected] = React.useState(false);\n  const [error, setError] = React.useState(null);\n  React.useEffect(() => {\n    const handleMessage = message => {\n      if (message.type === 'connection/established') {\n        setIsConnected(true);\n        setError(null);\n      } else if (message.type === 'connection/error') {\n        setError(message.payload);\n      }\n      if (onMessage) {\n        onMessage(message);\n      }\n    };\n\n    // Add the handler\n    const removeHandler = webSocketService.addMessageHandler(handleMessage);\n\n    // Clean up\n    return () => {\n      removeHandler();\n    };\n  }, [onMessage, ...dependencies]);\n};\n_s(useWebSocket, \"pC3TVIB/x3LrkaCp5yIVZyn0G4I=\");","map":{"version":3,"names":["WebSocketService","constructor","socket","messageHandlers","Set","errorHandlers","reconnectAttempts","maxReconnectAttempts","reconnectDelay","maxReconnectDelay","connectionStatus","connectionStatusListeners","reconnectTimeout","url","connect","console","log","Promise","resolve","reject","disconnect","WebSocket","updateConnectionStatus","onopen","event","readyState","extensions","protocol","onerror","error","_this$socket","_this$socket2","errorMessage","message","notifyErrorHandlers","wsError","Error","onmessage","notifyHandlers","data","onclose","code","attemptReconnect","close","status","notifyStatusChange","onStatusChange","callback","add","delete","forEach","getStatus","clear","sendMessage","OPEN","send","JSON","stringify","removeMessageHandler","handler","onError","removeErrorHandler","err","startCapture","interfaceName","type","interface","stopCapture","setFilter","filter","getInterfaces","getPackets","limit","filters","getStats","getBandwidth","Math","min","setTimeout","webSocketService","useWebSocket","onMessage","dependencies","_s","isConnected","setIsConnected","React","useState","setError","useEffect","handleMessage","payload","removeHandler","addMessageHandler"],"sources":["C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/src/services/websocketService.js"],"sourcesContent":["\nclass WebSocketService {\n  constructor() {\n    this.socket = null;\n    this.messageHandlers = new Set();\n    this.errorHandlers = new Set();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000; // Start with 1 second\n    this.maxReconnectDelay = 10000; // Max 10 seconds\n    this.connectionStatus = 'disconnected';\n    this.connectionStatusListeners = new Set();\n    this.reconnectTimeout = null;\n    this.url = null;\n  }\n\n  connect(url) {\n    this.url = url;\n    console.log(`[WebSocket] Initializing connection to ${url}`);\n    \n    return new Promise((resolve, reject) => {\n      try {\n        // Close existing connection if any\n        if (this.socket) {\n          console.log('[WebSocket] Closing existing connection...');\n          this.disconnect();\n        }\n\n        console.log(`[WebSocket] Creating new WebSocket instance to ${url}`);\n        this.socket = new WebSocket(url);\n        this.updateConnectionStatus('connecting');\n        \n        // Bind event handlers\n        this.socket.onopen = (event) => {\n          console.log('[WebSocket] Connection established', {\n            url: this.socket.url,\n            readyState: this.socket.readyState,\n            extensions: this.socket.extensions,\n            protocol: this.socket.protocol\n          });\n          this.reconnectAttempts = 0;\n          this.reconnectDelay = 1000;\n          this.updateConnectionStatus('connected');\n          resolve();\n        };\n        \n        this.socket.onerror = (error) => {\n          const errorMessage = `[WebSocket] Connection error: ${error.message || 'Unknown error'}`;\n          console.error(errorMessage, {\n            readyState: this.socket?.readyState,\n            url: this.socket?.url,\n            error\n          });\n          this.notifyErrorHandlers(error);\n          this.updateConnectionStatus('error');\n          \n          // Only reject if this is the initial connection attempt\n          if (this.reconnectAttempts === 0) {\n            const wsError = new Error(errorMessage);\n            console.error('[WebSocket] Rejecting connection promise', wsError);\n            reject(wsError);\n          }\n        };\n\n        this.socket.onmessage = (event) => {\n          try {\n            this.notifyHandlers(event.data);\n          } catch (error) {\n            console.error('Error handling WebSocket message:', error, event.data);\n            this.notifyErrorHandlers(error);\n          }\n        };\n\n        this.socket.onclose = (event) => {\n          console.log('WebSocket Disconnected', event);\n          this.updateConnectionStatus('disconnected');\n          \n          // Don't attempt to reconnect if the close was intentional\n          if (event.code !== 1000) {\n            this.attemptReconnect();\n          }\n        };\n\n        this.socket.onerror = (error) => {\n          console.error('WebSocket Error:', error);\n          this.updateConnectionStatus('error');\n          this.socket.close();\n          reject(error);\n        };\n      } catch (error) {\n        console.error('WebSocket Connection Error:', error);\n        reject(error);\n      }\n    });\n  }\n\n  updateConnectionStatus(status) {\n    this.connectionStatus = status;\n    this.notifyStatusChange(status);\n  }\n\n  onStatusChange(callback) {\n    this.connectionStatusListeners.add(callback);\n    return () => this.connectionStatusListeners.delete(callback);\n  }\n\n  notifyStatusChange(status) {\n    this.connectionStatusListeners.forEach(callback => {\n      try {\n        callback(status);\n      } catch (error) {\n        console.error('Error in status change handler:', error);\n      }\n    });\n  }\n\n  getStatus() {\n    return this.connectionStatus;\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n    this.messageHandlers.clear();\n  }\n\n  sendMessage(message) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(message));\n      return true;\n    }\n    console.error('WebSocket is not connected');\n    return false;\n  }\n\n  removeMessageHandler(handler) {\n    this.messageHandlers.delete(handler);\n  }\n\n  notifyHandlers(message) {\n    this.messageHandlers.forEach(handler => {\n      try {\n        handler(message);\n      } catch (error) {\n        console.error('Error in message handler:', error);\n        this.notifyErrorHandlers(error);\n      }\n    });\n  }\n\n  onError(handler) {\n    if (typeof handler === 'function') {\n      this.errorHandlers.add(handler);\n      return () => this.errorHandlers.delete(handler);\n    }\n    return () => {};\n  }\n\n  removeErrorHandler(handler) {\n    this.errorHandlers.delete(handler);\n  }\n\n  notifyErrorHandlers(error) {\n    this.errorHandlers.forEach(handler => {\n      try {\n        handler(error);\n      } catch (err) {\n        console.error('Error in error handler:', err);\n      }\n    });\n  }\n\n  // Network capture specific methods\n  startCapture(interfaceName) {\n    return this.sendMessage({\n      type: 'start_capture',\n      interface: interfaceName\n    });\n  }\n\n  stopCapture() {\n    return this.sendMessage({\n      type: 'stop_capture'\n    });\n  }\n\n  setFilter(filter) {\n    return this.sendMessage({\n      type: 'set_filter',\n      filter: filter\n    });\n  }\n\n  getInterfaces() {\n    return this.sendMessage({\n      type: 'get_interfaces'\n    });\n  }\n\n  getPackets(limit = 100, filters = {}) {\n    return this.sendMessage({\n      type: 'get_packets',\n      limit,\n      filters\n    });\n  }\n\n  getStats() {\n    return this.sendMessage({\n      type: 'get_stats'\n    });\n  }\n\n  getBandwidth() {\n    return this.sendMessage({\n      type: 'get_bandwidth'\n    });\n  }\n\n  attemptReconnect() {\n    this.reconnectAttempts++;\n    this.reconnectDelay = Math.min(this.reconnectDelay * 2, this.maxReconnectDelay);\n    this.reconnectTimeout = setTimeout(() => {\n      this.connect(this.url);\n    }, this.reconnectDelay);\n  }\n}\n\n// Export a singleton instance\nexport const webSocketService = new WebSocketService();\n\n// Helper hook for React components\nexport const useWebSocket = (onMessage, dependencies = []) => {\n  const [isConnected, setIsConnected] = React.useState(false);\n  const [error, setError] = React.useState(null);\n\n  React.useEffect(() => {\n    const handleMessage = (message) => {\n      if (message.type === 'connection/established') {\n        setIsConnected(true);\n        setError(null);\n      } else if (message.type === 'connection/error') {\n        setError(message.payload);\n      }\n      \n      if (onMessage) {\n        onMessage(message);\n      }\n    };\n\n    // Add the handler\n    const removeHandler = webSocketService.addMessageHandler(handleMessage);\n\n    // Clean up\n    return () => {\n      removeHandler();\n    };\n  }, [onMessage, ...dependencies]);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}