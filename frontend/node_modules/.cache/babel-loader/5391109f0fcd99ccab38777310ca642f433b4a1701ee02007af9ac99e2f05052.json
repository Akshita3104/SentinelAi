{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { webSocketService } from '../../services/websocketService';\n\n// WebSocket server URL (should be moved to environment variables in production)\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8080/ws';\nconst initialState = {\n  status: 'disconnected',\n  // 'disconnected', 'connecting', 'connected', 'error'\n  error: null,\n  interfaces: [],\n  activeInterface: null,\n  isCapturing: false,\n  packets: [],\n  stats: {\n    total: 0,\n    tcp: 0,\n    udp: 0,\n    http: 0,\n    https: 0,\n    dns: 0,\n    other: 0,\n    dropped: 0\n  },\n  bandwidth: {\n    in: 0,\n    out: 0,\n    history: [],\n    lastUpdate: null\n  },\n  filters: {\n    protocol: 'all',\n    sourceIp: '',\n    destinationIp: '',\n    port: ''\n  },\n  selectedPacket: null\n};\n\n// Thunks for WebSocket operations\nexport const connectToCapture = createAsyncThunk('network/connectToCapture', async (_, {\n  dispatch,\n  getState\n}) => {\n  try {\n    const {\n      activeInterface\n    } = getState().network;\n    if (!activeInterface) {\n      throw new Error('No network interface selected');\n    }\n\n    // Connect to WebSocket server\n    await webSocketService.connect(WS_URL);\n\n    // Set up message handler\n    webSocketService.addMessageHandler(message => {\n      switch (message.type) {\n        case 'packet':\n          dispatch(addPacket(message.payload));\n          break;\n        case 'stats/update':\n          dispatch(updateStats(message.payload));\n          break;\n        case 'bandwidth/update':\n          dispatch(updateBandwidth(message.payload));\n          break;\n        case 'interfaces/update':\n          dispatch(updateInterfaces(message.payload));\n          break;\n        case 'error':\n          console.error('WebSocket Error:', message.payload);\n          break;\n        default:\n          console.log('Unhandled message type:', message.type);\n      }\n    });\n\n    // Request initial data\n    webSocketService.sendMessage({\n      type: 'interfaces/list'\n    });\n    return {\n      status: 'connected'\n    };\n  } catch (error) {\n    console.error('WebSocket connection failed:', error);\n    return {\n      error: error.message\n    };\n  }\n});\nexport const startCapture = createAsyncThunk('network/startCapture', async (_, {\n  getState\n}) => {\n  const {\n    activeInterface\n  } = getState().network;\n  if (!activeInterface) {\n    throw new Error('No network interface selected');\n  }\n  const success = webSocketService.startCapture(activeInterface);\n  if (!success) {\n    throw new Error('Failed to send start capture command');\n  }\n  return {\n    success: true\n  };\n});\nexport const stopCapture = createAsyncThunk('network/stopCapture', async () => {\n  const success = webSocketService.stopCapture();\n  if (!success) {\n    throw new Error('Failed to send stop capture command');\n  }\n  return {\n    success: true\n  };\n});\nexport const updateCaptureFilter = createAsyncThunk('network/updateCaptureFilter', async (filter, {\n  getState\n}) => {\n  const success = webSocketService.setFilter(filter);\n  if (!success) {\n    throw new Error('Failed to update capture filter');\n  }\n  return {\n    filter\n  };\n});\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setActiveInterface: (state, action) => {\n      state.activeInterface = action.payload;\n      // When interface changes, clear existing packets\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0\n      };\n    },\n    addPacket: (state, action) => {\n      const packet = action.payload;\n      packet.timestamp = packet.timestamp || new Date().toISOString();\n      state.packets.unshift(packet);\n\n      // Keep only the last 1000 packets for performance\n      if (state.packets.length > 1000) {\n        state.packets.pop();\n      }\n    },\n    updateStats: (state, action) => {\n      state.stats = {\n        ...state.stats,\n        ...action.payload\n      };\n    },\n    updateBandwidth: (state, action) => {\n      const {\n        in: inBytes,\n        out: outBytes\n      } = action.payload;\n      const now = new Date().toISOString();\n      state.bandwidth.in = inBytes;\n      state.bandwidth.out = outBytes;\n      state.bandwidth.history.push({\n        timestamp: now,\n        in: inBytes,\n        out: outBytes\n      });\n\n      // Keep only the last 60 data points (1 minute at 1s intervals)\n      if (state.bandwidth.history.length > 60) {\n        state.bandwidth.history.shift();\n      }\n      state.bandwidth.lastUpdate = now;\n    },\n    updateInterfaces: (state, action) => {\n      state.interfaces = action.payload;\n      if (action.payload.length > 0 && !state.activeInterface) {\n        state.activeInterface = action.payload[0].name;\n      }\n    },\n    setFilter: (state, action) => {\n      state.filters = {\n        ...state.filters,\n        ...action.payload\n      };\n    },\n    selectPacket: (state, action) => {\n      state.selectedPacket = action.payload;\n    },\n    clearPackets: state => {\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0\n      };\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(connectToCapture.pending, state => {\n      state.status = 'connecting';\n    }).addCase(connectToCapture.fulfilled, (state, action) => {\n      if (action.payload.error) {\n        state.status = 'error';\n        state.error = action.payload.error;\n      } else {\n        state.status = 'connected';\n      }\n    }).addCase(connectToCapture.rejected, (state, action) => {\n      state.status = 'error';\n      state.error = action.error.message;\n    }).addCase(startCapture.pending, state => {\n      state.isCapturing = true;\n    }).addCase(startCapture.fulfilled, state => {\n      state.isCapturing = true;\n    }).addCase(startCapture.rejected, (state, action) => {\n      state.isCapturing = false;\n      state.error = action.error.message;\n    });\n  }\n});\nexport const {\n  setActiveInterface,\n  addPacket,\n  updateStats,\n  updateBandwidth,\n  updateInterfaces,\n  setFilter,\n  selectPacket,\n  clearPackets\n} = networkSlice.actions;\nexport default networkSlice.reducer;\n\n// Selectors\nexport const selectNetworkStatus = state => state.network.status;\nexport const selectInterfaces = state => state.network.interfaces;\nexport const selectActiveInterface = state => state.network.activeInterface;\nexport const selectIsCapturing = state => state.network.isCapturing;\nexport const selectPackets = state => state.network.packets;\nexport const selectStats = state => state.network.stats;\nexport const selectBandwidth = state => state.network.bandwidth;\nexport const selectFilters = state => state.network.filters;\nexport const selectSelectedPacket = state => state.network.selectedPacket;\nexport const selectFilteredPackets = state => {\n  const {\n    packets,\n    filters\n  } = state.network;\n\n  // Return empty array if filters are not initialized yet\n  if (!filters) {\n    return [];\n  }\n  const {\n    protocol = 'all',\n    sourceIp = '',\n    destinationIp = '',\n    port = ''\n  } = filters;\n  return packets.filter(packet => {\n    var _packet$protocol, _packet$source, _packet$destination;\n    // Filter by protocol\n    if (protocol !== 'all' && ((_packet$protocol = packet.protocol) === null || _packet$protocol === void 0 ? void 0 : _packet$protocol.toLowerCase()) !== protocol) {\n      return false;\n    }\n\n    // Filter by source IP\n    if (sourceIp && !((_packet$source = packet.source) !== null && _packet$source !== void 0 && _packet$source.includes(sourceIp))) {\n      return false;\n    }\n\n    // Filter by destination IP\n    if (destinationIp && !((_packet$destination = packet.destination) !== null && _packet$destination !== void 0 && _packet$destination.includes(destinationIp))) {\n      return false;\n    }\n\n    // Filter by port\n    if (port && !`${packet.sourcePort || ''}${packet.destinationPort || ''}`.includes(port)) {\n      return false;\n    }\n    return true;\n  });\n};\n\n// These actions are already exported from createAsyncThunk above","map":{"version":3,"names":["createSlice","createAsyncThunk","webSocketService","WS_URL","process","env","REACT_APP_WS_URL","initialState","status","error","interfaces","activeInterface","isCapturing","packets","stats","total","tcp","udp","http","https","dns","other","dropped","bandwidth","in","out","history","lastUpdate","filters","protocol","sourceIp","destinationIp","port","selectedPacket","connectToCapture","_","dispatch","getState","network","Error","connect","addMessageHandler","message","type","addPacket","payload","updateStats","updateBandwidth","updateInterfaces","console","log","sendMessage","startCapture","success","stopCapture","updateCaptureFilter","filter","setFilter","networkSlice","name","reducers","setActiveInterface","state","action","packet","timestamp","Date","toISOString","unshift","length","pop","inBytes","outBytes","now","push","shift","selectPacket","clearPackets","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","reducer","selectNetworkStatus","selectInterfaces","selectActiveInterface","selectIsCapturing","selectPackets","selectStats","selectBandwidth","selectFilters","selectSelectedPacket","selectFilteredPackets","_packet$protocol","_packet$source","_packet$destination","toLowerCase","source","includes","destination","sourcePort","destinationPort"],"sources":["C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/src/features/network/networkSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { webSocketService } from '../../services/websocketService';\n\n// WebSocket server URL (should be moved to environment variables in production)\nconst WS_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8080/ws';\n\nconst initialState = {\n  status: 'disconnected', // 'disconnected', 'connecting', 'connected', 'error'\n  error: null,\n  interfaces: [],\n  activeInterface: null,\n  isCapturing: false,\n  packets: [],\n  stats: {\n    total: 0,\n    tcp: 0,\n    udp: 0,\n    http: 0,\n    https: 0,\n    dns: 0,\n    other: 0,\n    dropped: 0,\n  },\n  bandwidth: {\n    in: 0,\n    out: 0,\n    history: [],\n    lastUpdate: null,\n  },\n  filters: {\n    protocol: 'all',\n    sourceIp: '',\n    destinationIp: '',\n    port: '',\n  },\n  selectedPacket: null,\n};\n\n// Thunks for WebSocket operations\nexport const connectToCapture = createAsyncThunk(\n  'network/connectToCapture',\n  async (_, { dispatch, getState }) => {\n    try {\n      const { activeInterface } = getState().network;\n      if (!activeInterface) {\n        throw new Error('No network interface selected');\n      }\n\n      // Connect to WebSocket server\n      await webSocketService.connect(WS_URL);\n      \n      // Set up message handler\n      webSocketService.addMessageHandler((message) => {\n        switch (message.type) {\n          case 'packet':\n            dispatch(addPacket(message.payload));\n            break;\n          case 'stats/update':\n            dispatch(updateStats(message.payload));\n            break;\n          case 'bandwidth/update':\n            dispatch(updateBandwidth(message.payload));\n            break;\n          case 'interfaces/update':\n            dispatch(updateInterfaces(message.payload));\n            break;\n          case 'error':\n            console.error('WebSocket Error:', message.payload);\n            break;\n          default:\n            console.log('Unhandled message type:', message.type);\n        }\n      });\n\n      // Request initial data\n      webSocketService.sendMessage({ type: 'interfaces/list' });\n      \n      return { status: 'connected' };\n    } catch (error) {\n      console.error('WebSocket connection failed:', error);\n      return { error: error.message };\n    }\n  }\n);\n\nexport const startCapture = createAsyncThunk(\n  'network/startCapture',\n  async (_, { getState }) => {\n    const { activeInterface } = getState().network;\n    if (!activeInterface) {\n      throw new Error('No network interface selected');\n    }\n    \n    const success = webSocketService.startCapture(activeInterface);\n    if (!success) {\n      throw new Error('Failed to send start capture command');\n    }\n    return { success: true };\n  }\n);\n\nexport const stopCapture = createAsyncThunk(\n  'network/stopCapture',\n  async () => {\n    const success = webSocketService.stopCapture();\n    if (!success) {\n      throw new Error('Failed to send stop capture command');\n    }\n    return { success: true };\n  }\n);\n\nexport const updateCaptureFilter = createAsyncThunk(\n  'network/updateCaptureFilter',\n  async (filter, { getState }) => {\n    const success = webSocketService.setFilter(filter);\n    if (!success) {\n      throw new Error('Failed to update capture filter');\n    }\n    return { filter };\n  }\n);\n\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setActiveInterface: (state, action) => {\n      state.activeInterface = action.payload;\n      // When interface changes, clear existing packets\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0,\n      };\n    },\n    addPacket: (state, action) => {\n      const packet = action.payload;\n      packet.timestamp = packet.timestamp || new Date().toISOString();\n      state.packets.unshift(packet);\n      \n      // Keep only the last 1000 packets for performance\n      if (state.packets.length > 1000) {\n        state.packets.pop();\n      }\n    },\n    updateStats: (state, action) => {\n      state.stats = { ...state.stats, ...action.payload };\n    },\n    updateBandwidth: (state, action) => {\n      const { in: inBytes, out: outBytes } = action.payload;\n      const now = new Date().toISOString();\n      \n      state.bandwidth.in = inBytes;\n      state.bandwidth.out = outBytes;\n      state.bandwidth.history.push({\n        timestamp: now,\n        in: inBytes,\n        out: outBytes\n      });\n      \n      // Keep only the last 60 data points (1 minute at 1s intervals)\n      if (state.bandwidth.history.length > 60) {\n        state.bandwidth.history.shift();\n      }\n      \n      state.bandwidth.lastUpdate = now;\n    },\n    updateInterfaces: (state, action) => {\n      state.interfaces = action.payload;\n      if (action.payload.length > 0 && !state.activeInterface) {\n        state.activeInterface = action.payload[0].name;\n      }\n    },\n    setFilter: (state, action) => {\n      state.filters = { ...state.filters, ...action.payload };\n    },\n    selectPacket: (state, action) => {\n      state.selectedPacket = action.payload;\n    },\n    clearPackets: (state) => {\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0,\n      };\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(connectToCapture.pending, (state) => {\n        state.status = 'connecting';\n      })\n      .addCase(connectToCapture.fulfilled, (state, action) => {\n        if (action.payload.error) {\n          state.status = 'error';\n          state.error = action.payload.error;\n        } else {\n          state.status = 'connected';\n        }\n      })\n      .addCase(connectToCapture.rejected, (state, action) => {\n        state.status = 'error';\n        state.error = action.error.message;\n      })\n      .addCase(startCapture.pending, (state) => {\n        state.isCapturing = true;\n      })\n      .addCase(startCapture.fulfilled, (state) => {\n        state.isCapturing = true;\n      })\n      .addCase(startCapture.rejected, (state, action) => {\n        state.isCapturing = false;\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport const {\n  setActiveInterface,\n  addPacket,\n  updateStats,\n  updateBandwidth,\n  updateInterfaces,\n  setFilter,\n  selectPacket,\n  clearPackets,\n} = networkSlice.actions;\n\nexport default networkSlice.reducer;\n\n// Selectors\nexport const selectNetworkStatus = (state) => state.network.status;\nexport const selectInterfaces = (state) => state.network.interfaces;\nexport const selectActiveInterface = (state) => state.network.activeInterface;\nexport const selectIsCapturing = (state) => state.network.isCapturing;\nexport const selectPackets = (state) => state.network.packets;\nexport const selectStats = (state) => state.network.stats;\nexport const selectBandwidth = (state) => state.network.bandwidth;\nexport const selectFilters = (state) => state.network.filters;\nexport const selectSelectedPacket = (state) => state.network.selectedPacket;\n\nexport const selectFilteredPackets = (state) => {\n  const { packets, filters } = state.network;\n  \n  // Return empty array if filters are not initialized yet\n  if (!filters) {\n    return [];\n  }\n  \n  const { protocol = 'all', sourceIp = '', destinationIp = '', port = '' } = filters;\n  \n  return packets.filter(packet => {\n    // Filter by protocol\n    if (protocol !== 'all' && packet.protocol?.toLowerCase() !== protocol) {\n      return false;\n    }\n    \n    // Filter by source IP\n    if (sourceIp && !packet.source?.includes(sourceIp)) {\n      return false;\n    }\n    \n    // Filter by destination IP\n    if (destinationIp && !packet.destination?.includes(destinationIp)) {\n      return false;\n    }\n    \n    // Filter by port\n    if (port && !`${packet.sourcePort || ''}${packet.destinationPort || ''}`.includes(port)) {\n      return false;\n    }\n    \n    return true;\n  });\n};\n\n// These actions are already exported from createAsyncThunk above\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}