{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// WebSocket connection\nlet socket = null;\nconst initialState = {\n  status: 'disconnected',\n  // 'disconnected', 'connecting', 'connected', 'error'\n  error: null,\n  interfaces: [],\n  activeInterface: null,\n  isCapturing: false,\n  packets: [],\n  stats: {\n    total: 0,\n    tcp: 0,\n    udp: 0,\n    http: 0,\n    https: 0,\n    dns: 0,\n    other: 0,\n    dropped: 0\n  },\n  bandwidth: {\n    in: 0,\n    out: 0,\n    history: [],\n    lastUpdate: null\n  },\n  filters: {\n    protocol: 'all',\n    sourceIp: '',\n    destinationIp: '',\n    port: ''\n  },\n  selectedPacket: null\n};\n\n// Thunks for WebSocket operations\nexport const connectToCapture = createAsyncThunk('network/connectToCapture', async (_, {\n  dispatch,\n  getState\n}) => {\n  try {\n    const {\n      activeInterface\n    } = getState().network;\n    if (!activeInterface) {\n      throw new Error('No network interface selected');\n    }\n\n    // In a real app, this would connect to your WebSocket server\n    // For now, we'll simulate the connection\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve({\n          status: 'connected'\n        });\n      }, 1000);\n    });\n  } catch (error) {\n    return {\n      error: error.message\n    };\n  }\n});\nexport const startCapture = createAsyncThunk('network/startCapture', async (_, {\n  dispatch,\n  getState\n}) => {\n  try {\n    // In a real app, this would send a start capture command to the WebSocket server\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve({\n          success: true\n        });\n      }, 500);\n    });\n  } catch (error) {\n    return {\n      error: error.message\n    };\n  }\n});\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setActiveInterface: (state, action) => {\n      state.activeInterface = action.payload;\n    },\n    addPacket: (state, action) => {\n      const packet = action.payload;\n      state.packets.unshift(packet);\n\n      // Update stats\n      state.stats.total++;\n\n      // Update protocol-specific counters\n      if (packet.protocol) {\n        const protocol = packet.protocol.toLowerCase();\n        if (['tcp', 'udp', 'http', 'https', 'dns'].includes(protocol)) {\n          state.stats[protocol]++;\n        } else {\n          state.stats.other++;\n        }\n      }\n\n      // Keep only the last 1000 packets for performance\n      if (state.packets.length > 1000) {\n        state.packets.pop();\n      }\n    },\n    updateBandwidth: (state, action) => {\n      const {\n        in: inBytes,\n        out: outBytes\n      } = action.payload;\n      const now = new Date().toISOString();\n      state.bandwidth.in = inBytes;\n      state.bandwidth.out = outBytes;\n      state.bandwidth.history.push({\n        timestamp: now,\n        in: inBytes,\n        out: outBytes\n      });\n\n      // Keep only the last 60 data points (1 minute at 1s intervals)\n      if (state.bandwidth.history.length > 60) {\n        state.bandwidth.history.shift();\n      }\n      state.bandwidth.lastUpdate = now;\n    },\n    setFilter: (state, action) => {\n      state.filters = {\n        ...state.filters,\n        ...action.payload\n      };\n    },\n    selectPacket: (state, action) => {\n      state.selectedPacket = action.payload;\n    },\n    clearPackets: state => {\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0\n      };\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(connectToCapture.pending, state => {\n      state.status = 'connecting';\n    }).addCase(connectToCapture.fulfilled, (state, action) => {\n      if (action.payload.error) {\n        state.status = 'error';\n        state.error = action.payload.error;\n      } else {\n        state.status = 'connected';\n      }\n    }).addCase(connectToCapture.rejected, (state, action) => {\n      state.status = 'error';\n      state.error = action.error.message;\n    }).addCase(startCapture.pending, state => {\n      state.isCapturing = true;\n    }).addCase(startCapture.fulfilled, state => {\n      state.isCapturing = true;\n    }).addCase(startCapture.rejected, (state, action) => {\n      state.isCapturing = false;\n      state.error = action.error.message;\n    });\n  }\n});\nexport const {\n  setActiveInterface,\n  addPacket,\n  updateBandwidth,\n  setFilter,\n  selectPacket,\n  clearPackets\n} = networkSlice.actions;\nexport default networkSlice.reducer;\n\n// Selectors\nexport const selectNetworkStatus = state => state.network.status;\nexport const selectInterfaces = state => state.network.interfaces;\nexport const selectActiveInterface = state => state.network.activeInterface;\nexport const selectIsCapturing = state => state.network.isCapturing;\nexport const selectPackets = state => state.network.packets;\nexport const selectStats = state => state.network.stats;\nexport const selectBandwidth = state => state.network.bandwidth;\nexport const selectFilters = state => state.network.filters;\nexport const selectSelectedPacket = state => state.network.selectedPacket;\nexport const selectFilteredPackets = state => {\n  const {\n    packets\n  } = state.network;\n  const {\n    protocol,\n    sourceIp,\n    destinationIp,\n    port\n  } = state.network.filters;\n  return packets.filter(packet => {\n    var _packet$protocol, _packet$source, _packet$destination;\n    // Filter by protocol\n    if (protocol !== 'all' && ((_packet$protocol = packet.protocol) === null || _packet$protocol === void 0 ? void 0 : _packet$protocol.toLowerCase()) !== protocol) {\n      return false;\n    }\n\n    // Filter by source IP\n    if (sourceIp && !((_packet$source = packet.source) !== null && _packet$source !== void 0 && _packet$source.includes(sourceIp))) {\n      return false;\n    }\n\n    // Filter by destination IP\n    if (destinationIp && !((_packet$destination = packet.destination) !== null && _packet$destination !== void 0 && _packet$destination.includes(destinationIp))) {\n      return false;\n    }\n\n    // Filter by port\n    if (port && !`${packet.sourcePort}${packet.destinationPort}`.includes(port)) {\n      return false;\n    }\n    return true;\n  });\n};","map":{"version":3,"names":["createSlice","createAsyncThunk","socket","initialState","status","error","interfaces","activeInterface","isCapturing","packets","stats","total","tcp","udp","http","https","dns","other","dropped","bandwidth","in","out","history","lastUpdate","filters","protocol","sourceIp","destinationIp","port","selectedPacket","connectToCapture","_","dispatch","getState","network","Error","Promise","resolve","setTimeout","message","startCapture","success","networkSlice","name","reducers","setActiveInterface","state","action","payload","addPacket","packet","unshift","toLowerCase","includes","length","pop","updateBandwidth","inBytes","outBytes","now","Date","toISOString","push","timestamp","shift","setFilter","selectPacket","clearPackets","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","reducer","selectNetworkStatus","selectInterfaces","selectActiveInterface","selectIsCapturing","selectPackets","selectStats","selectBandwidth","selectFilters","selectSelectedPacket","selectFilteredPackets","filter","_packet$protocol","_packet$source","_packet$destination","source","destination","sourcePort","destinationPort"],"sources":["C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/src/features/network/networkSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// WebSocket connection\nlet socket = null;\n\nconst initialState = {\n  status: 'disconnected', // 'disconnected', 'connecting', 'connected', 'error'\n  error: null,\n  interfaces: [],\n  activeInterface: null,\n  isCapturing: false,\n  packets: [],\n  stats: {\n    total: 0,\n    tcp: 0,\n    udp: 0,\n    http: 0,\n    https: 0,\n    dns: 0,\n    other: 0,\n    dropped: 0,\n  },\n  bandwidth: {\n    in: 0,\n    out: 0,\n    history: [],\n    lastUpdate: null,\n  },\n  filters: {\n    protocol: 'all',\n    sourceIp: '',\n    destinationIp: '',\n    port: '',\n  },\n  selectedPacket: null,\n};\n\n// Thunks for WebSocket operations\nexport const connectToCapture = createAsyncThunk(\n  'network/connectToCapture',\n  async (_, { dispatch, getState }) => {\n    try {\n      const { activeInterface } = getState().network;\n      if (!activeInterface) {\n        throw new Error('No network interface selected');\n      }\n\n      // In a real app, this would connect to your WebSocket server\n      // For now, we'll simulate the connection\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve({ status: 'connected' });\n        }, 1000);\n      });\n    } catch (error) {\n      return { error: error.message };\n    }\n  }\n);\n\nexport const startCapture = createAsyncThunk(\n  'network/startCapture',\n  async (_, { dispatch, getState }) => {\n    try {\n      // In a real app, this would send a start capture command to the WebSocket server\n      return new Promise((resolve) => {\n        setTimeout(() => {\n          resolve({ success: true });\n        }, 500);\n      });\n    } catch (error) {\n      return { error: error.message };\n    }\n  }\n);\n\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setActiveInterface: (state, action) => {\n      state.activeInterface = action.payload;\n    },\n    addPacket: (state, action) => {\n      const packet = action.payload;\n      state.packets.unshift(packet);\n      \n      // Update stats\n      state.stats.total++;\n      \n      // Update protocol-specific counters\n      if (packet.protocol) {\n        const protocol = packet.protocol.toLowerCase();\n        if (['tcp', 'udp', 'http', 'https', 'dns'].includes(protocol)) {\n          state.stats[protocol]++;\n        } else {\n          state.stats.other++;\n        }\n      }\n      \n      // Keep only the last 1000 packets for performance\n      if (state.packets.length > 1000) {\n        state.packets.pop();\n      }\n    },\n    updateBandwidth: (state, action) => {\n      const { in: inBytes, out: outBytes } = action.payload;\n      const now = new Date().toISOString();\n      \n      state.bandwidth.in = inBytes;\n      state.bandwidth.out = outBytes;\n      state.bandwidth.history.push({\n        timestamp: now,\n        in: inBytes,\n        out: outBytes\n      });\n      \n      // Keep only the last 60 data points (1 minute at 1s intervals)\n      if (state.bandwidth.history.length > 60) {\n        state.bandwidth.history.shift();\n      }\n      \n      state.bandwidth.lastUpdate = now;\n    },\n    setFilter: (state, action) => {\n      state.filters = { ...state.filters, ...action.payload };\n    },\n    selectPacket: (state, action) => {\n      state.selectedPacket = action.payload;\n    },\n    clearPackets: (state) => {\n      state.packets = [];\n      state.stats = {\n        total: 0,\n        tcp: 0,\n        udp: 0,\n        http: 0,\n        https: 0,\n        dns: 0,\n        other: 0,\n        dropped: 0,\n      };\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(connectToCapture.pending, (state) => {\n        state.status = 'connecting';\n      })\n      .addCase(connectToCapture.fulfilled, (state, action) => {\n        if (action.payload.error) {\n          state.status = 'error';\n          state.error = action.payload.error;\n        } else {\n          state.status = 'connected';\n        }\n      })\n      .addCase(connectToCapture.rejected, (state, action) => {\n        state.status = 'error';\n        state.error = action.error.message;\n      })\n      .addCase(startCapture.pending, (state) => {\n        state.isCapturing = true;\n      })\n      .addCase(startCapture.fulfilled, (state) => {\n        state.isCapturing = true;\n      })\n      .addCase(startCapture.rejected, (state, action) => {\n        state.isCapturing = false;\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport const {\n  setActiveInterface,\n  addPacket,\n  updateBandwidth,\n  setFilter,\n  selectPacket,\n  clearPackets,\n} = networkSlice.actions;\n\nexport default networkSlice.reducer;\n\n// Selectors\nexport const selectNetworkStatus = (state) => state.network.status;\nexport const selectInterfaces = (state) => state.network.interfaces;\nexport const selectActiveInterface = (state) => state.network.activeInterface;\nexport const selectIsCapturing = (state) => state.network.isCapturing;\nexport const selectPackets = (state) => state.network.packets;\nexport const selectStats = (state) => state.network.stats;\nexport const selectBandwidth = (state) => state.network.bandwidth;\nexport const selectFilters = (state) => state.network.filters;\nexport const selectSelectedPacket = (state) => state.network.selectedPacket;\n\nexport const selectFilteredPackets = (state) => {\n  const { packets } = state.network;\n  const { protocol, sourceIp, destinationIp, port } = state.network.filters;\n  \n  return packets.filter(packet => {\n    // Filter by protocol\n    if (protocol !== 'all' && packet.protocol?.toLowerCase() !== protocol) {\n      return false;\n    }\n    \n    // Filter by source IP\n    if (sourceIp && !packet.source?.includes(sourceIp)) {\n      return false;\n    }\n    \n    // Filter by destination IP\n    if (destinationIp && !packet.destination?.includes(destinationIp)) {\n      return false;\n    }\n    \n    // Filter by port\n    if (port && !`${packet.sourcePort}${packet.destinationPort}`.includes(port)) {\n      return false;\n    }\n    \n    return true;\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}