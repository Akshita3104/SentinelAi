{"ast":null,"code":"import { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit';\nimport { webSocketService } from './websocketService';\n\n// Helper function to safely access nested object properties\nconst safeGet = (obj, path, defaultValue = null) => {\n  return path.split('.').reduce((acc, key) => acc && acc[key] !== undefined ? acc[key] : defaultValue, obj);\n};\n\n// Default state with comprehensive defaults\nconst initialState = {\n  isConnected: false,\n  isCapturing: false,\n  interfaces: [],\n  currentInterface: null,\n  packets: [],\n  stats: {\n    packetCount: 0,\n    protocols: {\n      tcp: 0,\n      udp: 0,\n      icmp: 0,\n      other: 0\n    },\n    sourceIps: {},\n    destinationIps: {}\n  },\n  bandwidth: {\n    bpsReceived: 0,\n    bpsSent: 0,\n    totalReceived: 0,\n    totalSent: 0,\n    lastUpdated: null\n  },\n  detectedAttacks: [],\n  activeMitigations: {},\n  error: null,\n  lastUpdated: null\n};\n\n// Helper function to safely parse WebSocket messages\nconst parseWebSocketMessage = data => {\n  try {\n    if (typeof data === 'string') {\n      return JSON.parse(data);\n    }\n    return data;\n  } catch (error) {\n    console.error('Error parsing WebSocket message:', error, data);\n    return {\n      type: 'error',\n      error: 'Invalid message format'\n    };\n  }\n};\n\n// Async thunks\nexport const connectToBackend = createAsyncThunk('network/connect', async (_, {\n  dispatch,\n  rejectWithValue\n}) => {\n  try {\n    const wsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8080';\n    await webSocketService.connect(wsUrl);\n\n    // Set up message handler\n    const messageHandler = rawMessage => {\n      try {\n        const message = parseWebSocketMessage(rawMessage);\n        if (!message || !message.type) {\n          console.warn('Received message with no type:', message);\n          return;\n        }\n        switch (message.type) {\n          case 'init':\n            dispatch(setInterfaces(message.interfaces));\n            dispatch(setIsCapturing(message.is_capturing));\n            dispatch(setCurrentInterface(message.current_interface));\n            break;\n          case 'status':\n            dispatch(updateStats(message.stats));\n            dispatch(setBandwidth(message.bandwidth));\n            dispatch(setIsCapturing(message.is_capturing));\n            dispatch(setCurrentInterface(message.current_interface));\n            dispatch(updateMitigations(message.active_mitigations));\n            break;\n          case 'packet':\n            dispatch(addPacket(message.packet));\n            break;\n          case 'attack_detected':\n            dispatch(addDetectedAttack(message.attack));\n            break;\n          case 'mitigation_update':\n            dispatch(updateMitigations(message.active_mitigations));\n            break;\n          default:\n            console.warn('Unknown message type:', message.type);\n        }\n      } catch (error) {\n        console.error('Error in message handler:', error);\n      }\n    };\n\n    // Add message handler\n    const removeMessageHandler = webSocketService.addMessageHandler(messageHandler);\n\n    // Set up error handler\n    const errorHandler = error => {\n      console.error('WebSocket error:', error);\n      dispatch(setError(error.message || 'WebSocket connection error'));\n    };\n    const removeErrorHandler = webSocketService.onError(errorHandler);\n\n    // Return cleanup function\n    return () => {\n      removeMessageHandler();\n      removeErrorHandler();\n    };\n  } catch (error) {\n    console.error('Failed to connect to backend:', error);\n    return rejectWithValue({\n      error: error.message || 'Failed to connect to backend'\n    });\n  }\n});\nexport const startCapture = createAsyncThunk('network/startCapture', async (interfaceName, {\n  getState,\n  rejectWithValue\n}) => {\n  try {\n    await webSocketService.sendMessage({\n      type: 'start_capture',\n      interface: interfaceName\n    });\n    return {\n      interface: interfaceName\n    };\n  } catch (error) {\n    console.error('Failed to start capture:', error);\n    return rejectWithValue({\n      error: error.message || 'Failed to start capture'\n    });\n  }\n});\nexport const stopCapture = createAsyncThunk('network/stopCapture', async () => {\n  await webSocketService.sendMessage({\n    type: 'stop_capture'\n  });\n  return {\n    isCapturing: false\n  };\n});\nexport const applyMitigation = createAsyncThunk('network/applyMitigation', async ({\n  target,\n  action\n}, {\n  dispatch\n}) => {\n  await webSocketService.sendMessage({\n    type: 'mitigate',\n    target,\n    action\n  });\n  return {\n    target,\n    action\n  };\n});\nexport const reconnect = createAsyncThunk('network/reconnect', async () => {\n  await webSocketService.connect('ws://localhost:8080');\n  return {\n    reconnecting: false\n  };\n});\n\n// Slice\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setInterfaces: (state, action) => {\n      state.interfaces = Array.isArray(action.payload) ? action.payload : [];\n      state.lastUpdated = new Date().toISOString();\n    },\n    setIsCapturing: (state, action) => {\n      state.isCapturing = Boolean(action.payload);\n      state.lastUpdated = new Date().toISOString();\n    },\n    setCurrentInterface: (state, action) => {\n      state.currentInterface = action.payload || null;\n      state.lastUpdated = new Date().toISOString();\n    },\n    addPacket: (state, action) => {\n      const packet = action.payload || {};\n      // Ensure packet has required fields\n      if (packet.timestamp && (packet.src || packet.dst)) {\n        state.packets.unshift({\n          ...packet,\n          protocol: packet.protocol || 'unknown',\n          length: packet.length || 0,\n          info: packet.info || {},\n          timestamp: packet.timestamp || new Date().toISOString()\n        });\n\n        // Limit packet history\n        if (state.packets.length > 1000) {\n          state.packets.pop();\n        }\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    updateStats: (state, action) => {\n      if (action.payload) {\n        var _action$payload$proto, _action$payload$proto2, _action$payload$proto3, _action$payload$proto4;\n        state.stats = {\n          packetCount: Number(action.payload.packetCount) || state.stats.packetCount,\n          protocols: {\n            tcp: Number((_action$payload$proto = action.payload.protocols) === null || _action$payload$proto === void 0 ? void 0 : _action$payload$proto.tcp) || state.stats.protocols.tcp,\n            udp: Number((_action$payload$proto2 = action.payload.protocols) === null || _action$payload$proto2 === void 0 ? void 0 : _action$payload$proto2.udp) || state.stats.protocols.udp,\n            icmp: Number((_action$payload$proto3 = action.payload.protocols) === null || _action$payload$proto3 === void 0 ? void 0 : _action$payload$proto3.icmp) || state.stats.protocols.icmp,\n            other: Number((_action$payload$proto4 = action.payload.protocols) === null || _action$payload$proto4 === void 0 ? void 0 : _action$payload$proto4.other) || state.stats.protocols.other\n          },\n          sourceIps: action.payload.sourceIps || state.stats.sourceIps,\n          destinationIps: action.payload.destinationIps || state.stats.destinationIps\n        };\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    setBandwidth: (state, action) => {\n      if (action.payload) {\n        state.bandwidth = {\n          bpsReceived: Number(action.payload.bpsReceived) || 0,\n          bpsSent: Number(action.payload.bpsSent) || 0,\n          totalReceived: Number(action.payload.totalReceived) || 0,\n          totalSent: Number(action.payload.totalSent) || 0,\n          lastUpdated: new Date().toISOString()\n        };\n      }\n    },\n    addDetectedAttack: (state, action) => {\n      if (action.payload) {\n        state.detectedAttacks.unshift({\n          ...action.payload,\n          timestamp: action.payload.timestamp || new Date().toISOString()\n        });\n\n        // Limit attack history\n        if (state.detectedAttacks.length > 100) {\n          state.detectedAttacks.pop();\n        }\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    updateMitigations: (state, action) => {\n      if (action.payload && typeof action.payload === 'object') {\n        state.activeMitigations = {\n          ...state.activeMitigations,\n          ...action.payload\n        };\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    setError: (state, action) => {\n      state.error = action.payload;\n    },\n    setFilters: (state, action) => {\n      state.filters = action.payload;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(connectToBackend.fulfilled, state => {\n      state.isConnected = true;\n      state.error = null;\n    }).addCase(connectToBackend.rejected, (state, action) => {\n      state.isConnected = false;\n      state.error = action.error.message;\n    }).addCase(startCapture.fulfilled, (state, action) => {\n      state.isCapturing = true;\n      state.currentInterface = action.payload.interface;\n    }).addCase(stopCapture.fulfilled, state => {\n      state.isCapturing = false;\n    }).addCase(applyMitigation.fulfilled, (state, action) => {\n      const {\n        target,\n        action: mitigationAction\n      } = action.payload;\n      state.activeMitigations[target] = {\n        action: mitigationAction,\n        timestamp: new Date().toISOString(),\n        expires: new Date(Date.now() + 3600000).toISOString() // 1 hour from now\n      };\n    });\n  }\n});\n\n// Export actions\nexport const {\n  setInterfaces,\n  setIsCapturing,\n  setCurrentInterface,\n  addPacket,\n  updateStats,\n  setBandwidth,\n  addDetectedAttack,\n  updateMitigations,\n  setError,\n  setFilters\n} = networkSlice.actions;\n\n// Export selectors\nexport const selectIsConnected = state => state.network.isConnected;\nexport const selectIsCapturing = state => state.network.isCapturing;\nexport const selectInterfaces = state => state.network.interfaces;\nexport const selectCurrentInterface = state => state.network.currentInterface;\nexport const selectPackets = state => state.network.packets;\nexport const selectStats = state => state.network.stats;\nexport const selectBandwidth = state => state.network.bandwidth;\nexport const selectDetectedAttacks = state => state.network.detectedAttacks;\nexport const selectActiveMitigations = state => state.network.activeMitigations;\nexport const selectError = state => state.network.error;\nexport const selectFilters = state => state.network.filters;\n\n// Memoized selector for filtered packets\nexport const selectFilteredPackets = createSelector([state => state.network.packets, state => state.network.filters || {}], (packets, filters) => {\n  const {\n    protocol = 'all',\n    sourceIp = '',\n    destinationIp = '',\n    port = ''\n  } = filters;\n  return packets.filter(packet => {\n    const protocolMatch = protocol === 'all' || packet.protocol === protocol;\n    const sourceIpMatch = sourceIp === '' || packet.src === sourceIp;\n    const destinationIpMatch = destinationIp === '' || packet.dst === destinationIp;\n    const portMatch = port === '' || packet.port === Number(port);\n    return protocolMatch && sourceIpMatch && destinationIpMatch && portMatch;\n  });\n});\nexport default networkSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","createSelector","webSocketService","safeGet","obj","path","defaultValue","split","reduce","acc","key","undefined","initialState","isConnected","isCapturing","interfaces","currentInterface","packets","stats","packetCount","protocols","tcp","udp","icmp","other","sourceIps","destinationIps","bandwidth","bpsReceived","bpsSent","totalReceived","totalSent","lastUpdated","detectedAttacks","activeMitigations","error","parseWebSocketMessage","data","JSON","parse","console","type","connectToBackend","_","dispatch","rejectWithValue","wsUrl","process","env","REACT_APP_WS_URL","connect","messageHandler","rawMessage","message","warn","setInterfaces","setIsCapturing","is_capturing","setCurrentInterface","current_interface","updateStats","setBandwidth","updateMitigations","active_mitigations","addPacket","packet","addDetectedAttack","attack","removeMessageHandler","addMessageHandler","errorHandler","setError","removeErrorHandler","onError","startCapture","interfaceName","getState","sendMessage","interface","stopCapture","applyMitigation","target","action","reconnect","reconnecting","networkSlice","name","reducers","state","Array","isArray","payload","Date","toISOString","Boolean","timestamp","src","dst","unshift","protocol","length","info","pop","_action$payload$proto","_action$payload$proto2","_action$payload$proto3","_action$payload$proto4","Number","setFilters","filters","extraReducers","builder","addCase","fulfilled","rejected","mitigationAction","expires","now","actions","selectIsConnected","network","selectIsCapturing","selectInterfaces","selectCurrentInterface","selectPackets","selectStats","selectBandwidth","selectDetectedAttacks","selectActiveMitigations","selectError","selectFilters","selectFilteredPackets","sourceIp","destinationIp","port","filter","protocolMatch","sourceIpMatch","destinationIpMatch","portMatch","reducer"],"sources":["C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/src/services/networkService.js"],"sourcesContent":["import { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit';\nimport { webSocketService } from './websocketService';\n\n// Helper function to safely access nested object properties\nconst safeGet = (obj, path, defaultValue = null) => {\n  return path.split('.').reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : defaultValue), obj);\n};\n\n// Default state with comprehensive defaults\nconst initialState = {\n  isConnected: false,\n  isCapturing: false,\n  interfaces: [],\n  currentInterface: null,\n  packets: [],\n  stats: {\n    packetCount: 0,\n    protocols: {\n      tcp: 0,\n      udp: 0,\n      icmp: 0,\n      other: 0\n    },\n    sourceIps: {},\n    destinationIps: {}\n  },\n  bandwidth: {\n    bpsReceived: 0,\n    bpsSent: 0,\n    totalReceived: 0,\n    totalSent: 0,\n    lastUpdated: null\n  },\n  detectedAttacks: [],\n  activeMitigations: {},\n  error: null,\n  lastUpdated: null\n};\n\n// Helper function to safely parse WebSocket messages\nconst parseWebSocketMessage = (data) => {\n  try {\n    if (typeof data === 'string') {\n      return JSON.parse(data);\n    }\n    return data;\n  } catch (error) {\n    console.error('Error parsing WebSocket message:', error, data);\n    return { type: 'error', error: 'Invalid message format' };\n  }\n};\n\n// Async thunks\nexport const connectToBackend = createAsyncThunk(\n  'network/connect',\n  async (_, { dispatch, rejectWithValue }) => {\n    try {\n      const wsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8080';\n      await webSocketService.connect(wsUrl);\n      \n      // Set up message handler\n      const messageHandler = (rawMessage) => {\n        try {\n          const message = parseWebSocketMessage(rawMessage);\n          if (!message || !message.type) {\n            console.warn('Received message with no type:', message);\n            return;\n          }\n          switch (message.type) {\n            case 'init':\n              dispatch(setInterfaces(message.interfaces));\n              dispatch(setIsCapturing(message.is_capturing));\n              dispatch(setCurrentInterface(message.current_interface));\n              break;\n              \n            case 'status':\n              dispatch(updateStats(message.stats));\n              dispatch(setBandwidth(message.bandwidth));\n              dispatch(setIsCapturing(message.is_capturing));\n              dispatch(setCurrentInterface(message.current_interface));\n              dispatch(updateMitigations(message.active_mitigations));\n              break;\n              \n            case 'packet':\n              dispatch(addPacket(message.packet));\n              break;\n              \n            case 'attack_detected':\n              dispatch(addDetectedAttack(message.attack));\n              break;\n              \n            case 'mitigation_update':\n              dispatch(updateMitigations(message.active_mitigations));\n              break;\n              \n            default:\n              console.warn('Unknown message type:', message.type);\n          }\n        } catch (error) {\n          console.error('Error in message handler:', error);\n        }\n      };\n      \n      // Add message handler\n      const removeMessageHandler = webSocketService.addMessageHandler(messageHandler);\n      \n      // Set up error handler\n      const errorHandler = (error) => {\n        console.error('WebSocket error:', error);\n        dispatch(setError(error.message || 'WebSocket connection error'));\n      };\n      \n      const removeErrorHandler = webSocketService.onError(errorHandler);\n      \n      // Return cleanup function\n      return () => {\n        removeMessageHandler();\n        removeErrorHandler();\n      };\n    } catch (error) {\n      console.error('Failed to connect to backend:', error);\n      return rejectWithValue({ error: error.message || 'Failed to connect to backend' });\n    }\n  }\n);\n\nexport const startCapture = createAsyncThunk(\n  'network/startCapture',\n  async (interfaceName, { getState, rejectWithValue }) => {\n    try {\n      await webSocketService.sendMessage({\n        type: 'start_capture',\n        interface: interfaceName\n      });\n      return { interface: interfaceName };\n    } catch (error) {\n      console.error('Failed to start capture:', error);\n      return rejectWithValue({ error: error.message || 'Failed to start capture' });\n    }\n  }\n);\n\nexport const stopCapture = createAsyncThunk(\n  'network/stopCapture',\n  async () => {\n    await webSocketService.sendMessage({\n      type: 'stop_capture'\n    });\n    return { isCapturing: false };\n  }\n);\n\nexport const applyMitigation = createAsyncThunk(\n  'network/applyMitigation',\n  async ({ target, action }, { dispatch }) => {\n    await webSocketService.sendMessage({\n      type: 'mitigate',\n      target,\n      action\n    });\n    return { target, action };\n  }\n);\n\nexport const reconnect = createAsyncThunk(\n  'network/reconnect',\n  async () => {\n    await webSocketService.connect('ws://localhost:8080');\n    return { reconnecting: false };\n  }\n);\n\n// Slice\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState,\n  reducers: {\n    setInterfaces: (state, action) => {\n      state.interfaces = Array.isArray(action.payload) ? action.payload : [];\n      state.lastUpdated = new Date().toISOString();\n    },\n    setIsCapturing: (state, action) => {\n      state.isCapturing = Boolean(action.payload);\n      state.lastUpdated = new Date().toISOString();\n    },\n    setCurrentInterface: (state, action) => {\n      state.currentInterface = action.payload || null;\n      state.lastUpdated = new Date().toISOString();\n    },\n    addPacket: (state, action) => {\n      const packet = action.payload || {};\n      // Ensure packet has required fields\n      if (packet.timestamp && (packet.src || packet.dst)) {\n        state.packets.unshift({\n          ...packet,\n          protocol: packet.protocol || 'unknown',\n          length: packet.length || 0,\n          info: packet.info || {},\n          timestamp: packet.timestamp || new Date().toISOString()\n        });\n\n        // Limit packet history\n        if (state.packets.length > 1000) {\n          state.packets.pop();\n        }\n\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    updateStats: (state, action) => {\n      if (action.payload) {\n        state.stats = {\n          packetCount: Number(action.payload.packetCount) || state.stats.packetCount,\n          protocols: {\n            tcp: Number(action.payload.protocols?.tcp) || state.stats.protocols.tcp,\n            udp: Number(action.payload.protocols?.udp) || state.stats.protocols.udp,\n            icmp: Number(action.payload.protocols?.icmp) || state.stats.protocols.icmp,\n            other: Number(action.payload.protocols?.other) || state.stats.protocols.other\n          },\n          sourceIps: action.payload.sourceIps || state.stats.sourceIps,\n          destinationIps: action.payload.destinationIps || state.stats.destinationIps\n        };\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    setBandwidth: (state, action) => {\n      if (action.payload) {\n        state.bandwidth = {\n          bpsReceived: Number(action.payload.bpsReceived) || 0,\n          bpsSent: Number(action.payload.bpsSent) || 0,\n          totalReceived: Number(action.payload.totalReceived) || 0,\n          totalSent: Number(action.payload.totalSent) || 0,\n          lastUpdated: new Date().toISOString()\n        };\n      }\n    },\n    addDetectedAttack: (state, action) => {\n      if (action.payload) {\n        state.detectedAttacks.unshift({\n          ...action.payload,\n          timestamp: action.payload.timestamp || new Date().toISOString()\n        });\n\n        // Limit attack history\n        if (state.detectedAttacks.length > 100) {\n          state.detectedAttacks.pop();\n        }\n\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    updateMitigations: (state, action) => {\n      if (action.payload && typeof action.payload === 'object') {\n        state.activeMitigations = {\n          ...state.activeMitigations,\n          ...action.payload\n        };\n        state.lastUpdated = new Date().toISOString();\n      }\n    },\n    setError: (state, action) => {\n      state.error = action.payload;\n    },\n    setFilters: (state, action) => {\n      state.filters = action.payload;\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(connectToBackend.fulfilled, (state) => {\n        state.isConnected = true;\n        state.error = null;\n      })\n      .addCase(connectToBackend.rejected, (state, action) => {\n        state.isConnected = false;\n        state.error = action.error.message;\n      })\n      .addCase(startCapture.fulfilled, (state, action) => {\n        state.isCapturing = true;\n        state.currentInterface = action.payload.interface;\n      })\n      .addCase(stopCapture.fulfilled, (state) => {\n        state.isCapturing = false;\n      })\n      .addCase(applyMitigation.fulfilled, (state, action) => {\n        const { target, action: mitigationAction } = action.payload;\n        state.activeMitigations[target] = {\n          action: mitigationAction,\n          timestamp: new Date().toISOString(),\n          expires: new Date(Date.now() + 3600000).toISOString() // 1 hour from now\n        };\n      });\n  }\n});\n\n// Export actions\nexport const {\n  setInterfaces,\n  setIsCapturing,\n  setCurrentInterface,\n  addPacket,\n  updateStats,\n  setBandwidth,\n  addDetectedAttack,\n  updateMitigations,\n  setError,\n  setFilters\n} = networkSlice.actions;\n\n// Export selectors\nexport const selectIsConnected = (state) => state.network.isConnected;\nexport const selectIsCapturing = (state) => state.network.isCapturing;\nexport const selectInterfaces = (state) => state.network.interfaces;\nexport const selectCurrentInterface = (state) => state.network.currentInterface;\nexport const selectPackets = (state) => state.network.packets;\nexport const selectStats = (state) => state.network.stats;\nexport const selectBandwidth = (state) => state.network.bandwidth;\nexport const selectDetectedAttacks = (state) => state.network.detectedAttacks;\nexport const selectActiveMitigations = (state) => state.network.activeMitigations;\nexport const selectError = (state) => state.network.error;\nexport const selectFilters = (state) => state.network.filters;\n\n// Memoized selector for filtered packets\nexport const selectFilteredPackets = createSelector(\n  [\n    (state) => state.network.packets,\n    (state) => state.network.filters || {}\n  ],\n  (packets, filters) => {\n    const { protocol = 'all', sourceIp = '', destinationIp = '', port = '' } = filters;\n    return packets.filter(packet => {\n      const protocolMatch = protocol === 'all' || packet.protocol === protocol;\n      const sourceIpMatch = sourceIp === '' || packet.src === sourceIp;\n      const destinationIpMatch = destinationIp === '' || packet.dst === destinationIp;\n      const portMatch = port === '' || packet.port === Number(port);\n      return protocolMatch && sourceIpMatch && destinationIpMatch && portMatch;\n    });\n  }\n);\n\nexport default networkSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}