{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { webSocketService } from './websocketService';\n\n// Async thunks\nexport const connectToBackend = createAsyncThunk('network/connect', async (_, {\n  dispatch\n}) => {\n  try {\n    await webSocketService.connect('ws://localhost:8080');\n\n    // Set up message handlers\n    webSocketService.onMessage(message => {\n      switch (message.type) {\n        case 'init':\n          dispatch(setInterfaces(message.interfaces));\n          dispatch(setIsCapturing(message.is_capturing));\n          dispatch(setCurrentInterface(message.current_interface));\n          break;\n        case 'status':\n          dispatch(updateStats(message.stats));\n          dispatch(setBandwidth(message.bandwidth));\n          dispatch(setIsCapturing(message.is_capturing));\n          dispatch(setCurrentInterface(message.current_interface));\n          dispatch(updateMitigations(message.active_mitigations));\n          break;\n        case 'packet':\n          dispatch(addPacket(message.packet));\n          break;\n        case 'attack_detected':\n          dispatch(addDetectedAttack(message.attack));\n          break;\n        case 'mitigation_update':\n          dispatch(updateMitigations(message.active_mitigations));\n          break;\n        default:\n          console.warn('Unknown message type:', message.type);\n      }\n    });\n    return {\n      connected: true\n    };\n  } catch (error) {\n    console.error('Failed to connect to backend:', error);\n    throw error;\n  }\n});\nexport const startCapture = createAsyncThunk('network/startCapture', async (interfaceName, {\n  getState\n}) => {\n  await webSocketService.sendMessage({\n    type: 'start_capture',\n    interface: interfaceName\n  });\n  return {\n    interface: interfaceName\n  };\n});\nexport const stopCapture = createAsyncThunk('network/stopCapture', async () => {\n  await webSocketService.sendMessage({\n    type: 'stop_capture'\n  });\n  return {\n    isCapturing: false\n  };\n});\nexport const applyMitigation = createAsyncThunk('network/applyMitigation', async ({\n  target,\n  action\n}, {\n  dispatch\n}) => {\n  await webSocketService.sendMessage({\n    type: 'mitigate',\n    target,\n    action\n  });\n  return {\n    target,\n    action\n  };\n});\n\n// Slice\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState: {\n    isConnected: false,\n    isCapturing: false,\n    interfaces: [],\n    currentInterface: null,\n    packets: [],\n    stats: {\n      packetCount: 0,\n      protocols: {},\n      sourceIps: {},\n      destinationIps: {}\n    },\n    bandwidth: {\n      bpsSent: 0,\n      bpsReceived: 0,\n      totalSent: 0,\n      totalReceived: 0\n    },\n    detectedAttacks: [],\n    activeMitigations: {},\n    error: null\n  },\n  reducers: {\n    setInterfaces: (state, action) => {\n      state.interfaces = action.payload;\n    },\n    setIsCapturing: (state, action) => {\n      state.isCapturing = action.payload;\n    },\n    setCurrentInterface: (state, action) => {\n      state.currentInterface = action.payload;\n    },\n    addPacket: (state, action) => {\n      state.packets.unshift(action.payload);\n      if (state.packets.length > 1000) {\n        state.packets.pop();\n      }\n    },\n    updateStats: (state, action) => {\n      state.stats = {\n        packetCount: action.payload.packet_count,\n        protocols: action.payload.protocols,\n        sourceIps: action.payload.source_ips,\n        destinationIps: action.payload.destination_ips\n      };\n    },\n    setBandwidth: (state, action) => {\n      state.bandwidth = {\n        bpsSent: action.payload.bps_sent,\n        bpsReceived: action.payload.bps_received,\n        totalSent: action.payload.total_sent,\n        totalReceived: action.payload.total_received\n      };\n    },\n    addDetectedAttack: (state, action) => {\n      state.detectedAttacks.unshift({\n        ...action.payload,\n        timestamp: new Date().toISOString()\n      });\n    },\n    updateMitigations: (state, action) => {\n      state.activeMitigations = action.payload;\n    },\n    setError: (state, action) => {\n      state.error = action.payload;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(connectToBackend.fulfilled, state => {\n      state.isConnected = true;\n      state.error = null;\n    }).addCase(connectToBackend.rejected, (state, action) => {\n      state.isConnected = false;\n      state.error = action.error.message;\n    });\n  }\n});\n\n// Export actions\nexport const {\n  setInterfaces,\n  setIsCapturing,\n  setCurrentInterface,\n  addPacket,\n  updateStats,\n  setBandwidth,\n  addDetectedAttack,\n  updateMitigations,\n  setError\n} = networkSlice.actions;\n\n// Export selectors\nexport const selectIsConnected = state => state.network.isConnected;\nexport const selectIsCapturing = state => state.network.isCapturing;\nexport const selectInterfaces = state => state.network.interfaces;\nexport const selectCurrentInterface = state => state.network.currentInterface;\nexport const selectPackets = state => state.network.packets;\nexport const selectStats = state => state.network.stats;\nexport const selectBandwidth = state => state.network.bandwidth;\nexport const selectDetectedAttacks = state => state.network.detectedAttacks;\nexport const selectActiveMitigations = state => state.network.activeMitigations;\nexport const selectError = state => state.network.error;\nexport default networkSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","webSocketService","connectToBackend","_","dispatch","connect","onMessage","message","type","setInterfaces","interfaces","setIsCapturing","is_capturing","setCurrentInterface","current_interface","updateStats","stats","setBandwidth","bandwidth","updateMitigations","active_mitigations","addPacket","packet","addDetectedAttack","attack","console","warn","connected","error","startCapture","interfaceName","getState","sendMessage","interface","stopCapture","isCapturing","applyMitigation","target","action","networkSlice","name","initialState","isConnected","currentInterface","packets","packetCount","protocols","sourceIps","destinationIps","bpsSent","bpsReceived","totalSent","totalReceived","detectedAttacks","activeMitigations","reducers","state","payload","unshift","length","pop","packet_count","source_ips","destination_ips","bps_sent","bps_received","total_sent","total_received","timestamp","Date","toISOString","setError","extraReducers","builder","addCase","fulfilled","rejected","actions","selectIsConnected","network","selectIsCapturing","selectInterfaces","selectCurrentInterface","selectPackets","selectStats","selectBandwidth","selectDetectedAttacks","selectActiveMitigations","selectError","reducer"],"sources":["C:/Users/Akshita/OneDrive - somaiya.edu/Akshita/Projects/SentinelAi/frontend/src/services/networkService.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { webSocketService } from './websocketService';\n\n// Async thunks\nexport const connectToBackend = createAsyncThunk(\n  'network/connect',\n  async (_, { dispatch }) => {\n    try {\n      await webSocketService.connect('ws://localhost:8080');\n      \n      // Set up message handlers\n      webSocketService.onMessage((message) => {\n        switch (message.type) {\n          case 'init':\n            dispatch(setInterfaces(message.interfaces));\n            dispatch(setIsCapturing(message.is_capturing));\n            dispatch(setCurrentInterface(message.current_interface));\n            break;\n            \n          case 'status':\n            dispatch(updateStats(message.stats));\n            dispatch(setBandwidth(message.bandwidth));\n            dispatch(setIsCapturing(message.is_capturing));\n            dispatch(setCurrentInterface(message.current_interface));\n            dispatch(updateMitigations(message.active_mitigations));\n            break;\n            \n          case 'packet':\n            dispatch(addPacket(message.packet));\n            break;\n            \n          case 'attack_detected':\n            dispatch(addDetectedAttack(message.attack));\n            break;\n            \n          case 'mitigation_update':\n            dispatch(updateMitigations(message.active_mitigations));\n            break;\n            \n          default:\n            console.warn('Unknown message type:', message.type);\n        }\n      });\n      \n      return { connected: true };\n    } catch (error) {\n      console.error('Failed to connect to backend:', error);\n      throw error;\n    }\n  }\n);\n\nexport const startCapture = createAsyncThunk(\n  'network/startCapture',\n  async (interfaceName, { getState }) => {\n    await webSocketService.sendMessage({\n      type: 'start_capture',\n      interface: interfaceName\n    });\n    return { interface: interfaceName };\n  }\n);\n\nexport const stopCapture = createAsyncThunk(\n  'network/stopCapture',\n  async () => {\n    await webSocketService.sendMessage({\n      type: 'stop_capture'\n    });\n    return { isCapturing: false };\n  }\n);\n\nexport const applyMitigation = createAsyncThunk(\n  'network/applyMitigation',\n  async ({ target, action }, { dispatch }) => {\n    await webSocketService.sendMessage({\n      type: 'mitigate',\n      target,\n      action\n    });\n    return { target, action };\n  }\n);\n\n// Slice\nconst networkSlice = createSlice({\n  name: 'network',\n  initialState: {\n    isConnected: false,\n    isCapturing: false,\n    interfaces: [],\n    currentInterface: null,\n    packets: [],\n    stats: {\n      packetCount: 0,\n      protocols: {},\n      sourceIps: {},\n      destinationIps: {}\n    },\n    bandwidth: {\n      bpsSent: 0,\n      bpsReceived: 0,\n      totalSent: 0,\n      totalReceived: 0\n    },\n    detectedAttacks: [],\n    activeMitigations: {},\n    error: null\n  },\n  reducers: {\n    setInterfaces: (state, action) => {\n      state.interfaces = action.payload;\n    },\n    setIsCapturing: (state, action) => {\n      state.isCapturing = action.payload;\n    },\n    setCurrentInterface: (state, action) => {\n      state.currentInterface = action.payload;\n    },\n    addPacket: (state, action) => {\n      state.packets.unshift(action.payload);\n      if (state.packets.length > 1000) {\n        state.packets.pop();\n      }\n    },\n    updateStats: (state, action) => {\n      state.stats = {\n        packetCount: action.payload.packet_count,\n        protocols: action.payload.protocols,\n        sourceIps: action.payload.source_ips,\n        destinationIps: action.payload.destination_ips\n      };\n    },\n    setBandwidth: (state, action) => {\n      state.bandwidth = {\n        bpsSent: action.payload.bps_sent,\n        bpsReceived: action.payload.bps_received,\n        totalSent: action.payload.total_sent,\n        totalReceived: action.payload.total_received\n      };\n    },\n    addDetectedAttack: (state, action) => {\n      state.detectedAttacks.unshift({\n        ...action.payload,\n        timestamp: new Date().toISOString()\n      });\n    },\n    updateMitigations: (state, action) => {\n      state.activeMitigations = action.payload;\n    },\n    setError: (state, action) => {\n      state.error = action.payload;\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(connectToBackend.fulfilled, (state) => {\n        state.isConnected = true;\n        state.error = null;\n      })\n      .addCase(connectToBackend.rejected, (state, action) => {\n        state.isConnected = false;\n        state.error = action.error.message;\n      });\n  }\n});\n\n// Export actions\nexport const {\n  setInterfaces,\n  setIsCapturing,\n  setCurrentInterface,\n  addPacket,\n  updateStats,\n  setBandwidth,\n  addDetectedAttack,\n  updateMitigations,\n  setError\n} = networkSlice.actions;\n\n// Export selectors\nexport const selectIsConnected = (state) => state.network.isConnected;\nexport const selectIsCapturing = (state) => state.network.isCapturing;\nexport const selectInterfaces = (state) => state.network.interfaces;\nexport const selectCurrentInterface = (state) => state.network.currentInterface;\nexport const selectPackets = (state) => state.network.packets;\nexport const selectStats = (state) => state.network.stats;\nexport const selectBandwidth = (state) => state.network.bandwidth;\nexport const selectDetectedAttacks = (state) => state.network.detectedAttacks;\nexport const selectActiveMitigations = (state) => state.network.activeMitigations;\nexport const selectError = (state) => state.network.error;\n\nexport default networkSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}